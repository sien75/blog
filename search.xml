<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript基础</title>
    <url>/blog/2020/08/11/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文为《JavaScript高级程序设计》（第3版）前14章的笔记，没有全部摘录，不是关于JavaScript的教程，如果您对JavaScript不熟悉，强烈建议您阅读《JavaScript高级程序设计》（第3版），该书对ES5标准的JavaScript有既详实又易懂的介绍。在经过几次面试后，深感自己的JavaScript基础知识不是很好，所以又重新读了这本书的前14章，并把其中的有利于理解JavaScript的基础概念（如<strong>原型链</strong>、事件流），以及一些我觉得有价值的知识点整理了一下，在其上做了些补充。另外，如本文和ES6有冲突，以ES6为准。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>函数内var定义的数据，在函数外无法访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(test);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>在全局作用域直接定义的变量是全局变量；省略var操作符，直接使用的变量是全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    test2 = <span class="number">2</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.test1 === test1);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.test2 === test2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>ECMAScript有5中基本数据类型，分别是<code>Undefined</code> <code>Null</code> <code>Boolean</code> <code>String</code> <code>Number</code>。</p>
</li>
<li><p><code>typeof null === &#39;object&#39;</code>，typeof共有6种结果，分别是<code>&#39;undefined&#39;</code> <code>&#39;boolean&#39;</code> <code>&#39;string&#39;</code> <code>&#39;number&#39;</code> <code>&#39;object&#39;</code> <code>&#39;function&#39;</code>。</p>
</li>
<li><p>不需要显式指定<code>undefined</code>值，仅用作比较；未声明和未初始化的变量都是<code>undefined</code>。</p>
</li>
<li><p>一些默认的转换函数：<code>Boolean()</code> <code>Number()</code>  <code>String()</code>，推荐使用这些函数转换类型。</p>
</li>
<li><p><code>parseInt(string, n)</code>和<code>number.toString(n)</code>函数中的n(2,8,10,16)可以设置<strong>字符串指代数字</strong>的进制，比如下面第一行就是指11是一个16进制数字的字符串，第二行就是指转换后的字符串所代表数字为16进制。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">16</span>);<span class="comment">//17</span></span><br><span class="line"><span class="number">11.</span>toString(<span class="number">16</span>);<span class="comment">//&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按位非<code>~</code>，按位与<code>&amp;</code>，按位或<code>|</code>，按位异或<code>^</code>，左移<code>&lt;&lt;</code>，有符号右移<code>&gt;&gt;</code>，无符号右移<code>&gt;&gt;&gt;</code>。</p>
</li>
<li><p><code>&amp;&amp;</code>和<code>||</code>是短路操作符。</p>
</li>
<li><p>存在字符串时，把数字运算括起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;1 + 2 = &#x27;</span> + (<span class="number">1</span> + <span class="number">2</span>);<span class="comment">//&#x27;1 + 2 = 3&#x27;。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code>操作符比较时，除<code>null</code>和<code>undefined</code>外：若两个基本值类型不同，总是将两者转换为数字进行比较；若一个值为引用类型，则使用String()函数将其转换成字符串后再比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> &lt; <span class="number">2</span>;<span class="comment">//true</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span>;<span class="comment">//true</span></span><br><span class="line">[<span class="number">11</span>] == <span class="number">0xb</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">a == <span class="string">&#x27;[object Object]&#x27;</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>undefined == null</code>，且和其他值比较时不进行类型转换，所以均为<code>false</code>，虽然<code>isNaN(Number(undefined)) === true</code> <code>Number(null) === 0</code>。</p>
</li>
<li><p>模赋值<code>%=</code>，有符号左移赋值<code>&lt;&lt;=</code>，有符号右移赋值<code>&gt;&gt;=</code>，无符号右移赋值<code>&gt;&gt;&gt;=</code>。</p>
</li>
<li><p><code>for</code>循环和<code>for-of</code>能用于可迭代的数据类型，如字符串（的基本包装类型）和数组；<br><code>for-in</code>能用于对象（包括数组）和字符串。</p>
</li>
<li><p>label语句可以和break或continue语句联合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">here:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>) <span class="keyword">break</span> here;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//55</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments和命名参数的值保持同步。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)(<span class="number">0</span>)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ECMAScript没有函数重载，但可以根据参数做出不同的反应，模仿函数重载。</p>
</li>
</ol>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ol>
<li><p>检测引用类型时使用<code>instanceof</code>，该操作符可确认某对象的所有构造函数（这里的构造函数指，只要其prototype指向该对象的原型链上某个对象，那就算该对象的广义上的构造函数）。</p>
</li>
<li><p>Array实例的一些方法：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join();<span class="comment">//&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">&#x27;|&#x27;</span>);<span class="comment">//&quot;1|2|3&quot;</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reverse();<span class="comment">//[3, 2, 1], 数组本身会变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>&#125;);<span class="comment">//[1, 2, 3], 需要排列则返回1, 否则返回-1, 数组本身会变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].lastIndexOf(<span class="number">0</span>);<span class="comment">//3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, cur</span>) </span>&#123;<span class="keyword">return</span> pre + cur;&#125;);<span class="comment">//6</span></span><br><span class="line">[&#123;<span class="attr">x</span> : <span class="number">1</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, cur</span>) </span>&#123;<span class="keyword">return</span> pre + cur.x;&#125;, <span class="number">0</span>);<span class="comment">//3, 0为初始值</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, cur</span>) </span>&#123;<span class="keyword">return</span> pre.concat(cur);&#125;);<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用Date创建日期对象时，若不想使用当前时间，而是使用指定时间，可使用以下命令：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);<span class="comment">//2015年5月5日下午5点55分55秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用RegExp构造函数创建正则表达式时，需要对字符串双重转义，RegExp使用的是字符串的输出值（console.log()），并不清楚字符串内部细节，<br>所以字符串实际的输出值需要和字面量模式下保持一致。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg00 = <span class="regexp">/\[error\]/</span>;</span><br><span class="line"><span class="keyword">var</span> reg01 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\[error\\]&#x27;</span>);<span class="comment">//上面两个正则表达式相同，匹配&quot;[error]&quot;字符串</span></span><br><span class="line"><span class="keyword">var</span> reg10 = <span class="regexp">/\\n/g</span>;</span><br><span class="line"><span class="keyword">var</span> reg11 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\\\n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);<span class="comment">//上面两个正则表达式相同，并不是匹配换行符，而是全局匹配&quot;\n&quot;这样的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RegExp实例的方法exec：在正则表达式不设全局标志时，该方法只会不断返回第一个匹配项；在正则表达式设置全局标志时，对于相同的字符串，该方法<br>会依次返回匹配的字符串，最后返回null；<br>RegExp实例的方法test：符合返回true，不符合返回false。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = str2 = <span class="string">&#x27;cat, rat&#x27;</span>;</span><br><span class="line">pattern.exec(str1);<span class="comment">//&#123;0: &#x27;cat&#x27;, index: 0&#125;</span></span><br><span class="line">pattern.exec(str2);<span class="comment">//&#123;0: &#x27;rat&#x27;, index: 5&#125;</span></span><br><span class="line">pattern.exec(str1);<span class="comment">//null</span></span><br><span class="line">pattern.exec(str2);<span class="comment">//&#123;0: &#x27;cat&#x27;, index: 0&#125;</span></span><br><span class="line">pattern.test(<span class="string">&#x27;cat&#x27;</span>);<span class="comment">//true</span></span><br><span class="line">pattern.test(<span class="string">&#x27;dog&#x27;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Function实例的方法apply，call，bind：扩充函数作用域。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;chosen a&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;chosen b&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span> (<span class="params">choice</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>[choice]) &#125;</span><br><span class="line">show.apply(obj, [<span class="string">&#x27;a&#x27;</span>]);<span class="comment">//chosen a</span></span><br><span class="line">show.call(obj, <span class="string">&#x27;b&#x27;</span>);<span class="comment">//chosen b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">msg</span>) </span>&#123; <span class="built_in">this</span>.log(msg) &#125;</span><br><span class="line">log = log.bind(<span class="built_in">console</span>);</span><br><span class="line">log(<span class="string">&#x27;hello bind&#x27;</span>);<span class="comment">//hello bind</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Number实例的一些方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>);<span class="comment">//10.00</span></span><br><span class="line">num.toExponential();<span class="comment">//1e+1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>String实例和String构造函数的一些方法：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world!&#x27;</span>;</span><br><span class="line">str.charAt(<span class="number">1</span>);<span class="comment">//e</span></span><br><span class="line">str.charCodeAt(<span class="number">1</span>);<span class="comment">//101</span></span><br><span class="line">str.match(<span class="regexp">/.o/g</span>);<span class="comment">//[&#x27;lo&#x27;, &#x27;wo&#x27;]</span></span><br><span class="line">str.search(<span class="regexp">/.o/g</span>);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><ol>
<li><p>对象有两种属性: 数据属性和访问器属性.</p>
<p>直接定义的属性都是数据属性, 数据属性有4个描述其行为的特性:</p>
<ul>
<li><p>Configurable, 能否通过<code>delete</code>删除属性, 能否修改Configurale和Enumerable, 能否修改Writable为<code>true</code>, 能否将属性变更为访问器属性</p>
</li>
<li><p>Enumerable, 能否通过for-in访问到属性</p>
</li>
<li><p>Writable, 能否更改属性的值</p>
</li>
<li><p>Value, 属性的值<br>直接定义的属性前三个特性值都为<code>true</code>, Value为指定的值或<code>undefined</code>. 除了直接定义, 我们还可以通过<code>Object.defineProperty</code>来定义和修改对象的数据属性. 例子如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    enumerable: <span class="string">`true`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>前三个特性值不指定均默认为<code>false</code>, 即该数据属性不可删除, 不可枚举, 也不可修改属性值, Configurale和Enumerable也不能修改, Writable不能由<code>false</code>修改为<code>true</code>.</p>
<p>访问器属性不包括Value, 它包括以下4个描述其行为的特性:</p>
<ul>
<li>Configurable, 能否通过<code>delete</code>删除属性, 能否修改属性的4个特性, 能否将属性变更为访问器属性</li>
<li>Enumerable, 能否通过for-in访问到属性</li>
<li>Set, 在写入时调用的函数</li>
<li>Get, 在读取时调用的函数<br>访问器属性不能直接定义, 需要通过<code>Object.defineProperty</code>来定义和修改对象的访问器属性, 指定Get或Set即为设置访问器属性. 例子如下:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">_a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._a = v;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以通过<code>Object.defineProperties</code>定义多个属性.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="string">&#x27;name1&#x27;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&#x27;name2&#x27;</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以通过<code>Object.getOwnPropertyDescriptor(obj, &#39;name&#39;)</code>来读取属性的特性.</p>
</li>
</ul>
</li>
<li><p>按照构造函数模式创建对象：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Sam&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Sam&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.call(person);</span><br><span class="line"><span class="comment">//构造函数的实际过程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照原型模式创建对象：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = [<span class="string">&#x27;Sam&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> person0 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person0.name === person1.name;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照构造函数模式创建对象的好处是可以标识，按照原型模式创建对象的好处是可以共享。<br>可以组合利用两种模式，利用构造函数模式定义特有属性，利用原型模式定义方法和共享属性。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);&#125;</span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.age);&#125;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> person0 = <span class="keyword">new</span> Person(<span class="string">&#x27;Sam&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Amy&#x27;</span>);</span><br><span class="line"><span class="keyword">with</span>(person0) &#123;sayName(); sayAge()&#125;;<span class="comment">//Sam, 20</span></span><br><span class="line"><span class="keyword">with</span>(person1) &#123;sayName(); sayAge()&#125;;<span class="comment">//Amy, 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以下代码中，构造函数、原型和实例的关系如图：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = <span class="string">&#x27;super&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = <span class="string">&#x27;sub&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="keyword">with</span>(instance) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getValue(), superValue, subValue);</span><br><span class="line">&#125;<span class="comment">//sub super sub</span></span><br></pre></td></tr></table></figure>
<p> <img src="./prototype.png" alt="prototype"></p>
</li>
<li><p>搜索对象属性和方法会按照实例-原型依次向上查找, 直到找到为止, 所以实例中的属性和方法可以屏蔽掉原型中的属性和方法, 如4中的getValue. 为了确定属性和方法的来源, 以及获取所有属性和方法, 可以按照以下表格的思路(Symbol类型是ES6中的新数据类型, 为了总结, 将它的遍历和检测方法一并放到这里):</p>
<p>遍历方法:</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">自身可迭代属性</th>
<th align="center">自身不可迭代属性</th>
<th align="center">自身Symbol属性</th>
<th align="center">继承可迭代属性</th>
<th align="center">继承不可迭代属性</th>
<th align="left">继承Symbol属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Object.keys(obj)</code></td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>Object.getOwnPropertyNames(obj)</code></td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>for(name in obj)</code></td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">*</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>Object.getOwnPropertySymbols(obj)</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>Reflect.ownKeys(obj)</code></td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>检测方法:</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">自身可迭代属性</th>
<th align="center">自身不可迭代属性</th>
<th align="center">自身Symbol属性</th>
<th align="center">继承可迭代属性</th>
<th align="center">继承不可迭代属性</th>
<th align="left">继承Symbol属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>obj.hasOwnProperty(name)</code></td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>name in obj</code></td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="left">*</td>
</tr>
</tbody></table>
</li>
<li><p>使用原型链进行方法和共享属性的继承，使用构造函数进行一般属性的继承，这就是组合继承。组合继承如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">sup, sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = sub;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, sup);<span class="comment">//通过构造函数继承一般属性，第2次调用SuperValue</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(<span class="string">&#x27;super0&#x27;</span>);<span class="comment">//通过原型链继承方法和共享属性，第1次调用SuperValue</span></span><br><span class="line">SubType.prototype.getSub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">&#x27;super1&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>);</span><br><span class="line"><span class="keyword">with</span>(instance) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getSub(), getSuper());</span><br><span class="line">&#125;<span class="comment">//sub super1</span></span><br></pre></td></tr></table></figure>
<p> 构造函数、原型和实例的关系如图：<br> <img src="./combination_inheritance.png" alt="组合继承"></p>
</li>
<li><p>可以看出，组合继承两次调用SuperValue，使得instance.superValue被定义了两次，发生了重复。我们的原则是一般的属性不应该进入原型链，共享属性和方法进入原型链，实现真正的共享属性和方法通过原型链继承，一般属性通过构造函数继承，寄生组合继承是最终的解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = prototype;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">sup, sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = sub;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, sup);<span class="comment">//通过构造函数继承一般属性</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = inheritPrototype(SuperType.prototype);<span class="comment">//通过原型链继承方法和共享属性</span></span><br><span class="line">SubType.prototype.getSub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>);</span><br><span class="line"><span class="keyword">with</span>(instance) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getSub(), getSuper());</span><br><span class="line">&#125;<span class="comment">//sub super</span></span><br></pre></td></tr></table></figure>
<p><img src="./parasitic_combination_inheritance.png" alt="寄生组合继承"></p>
</li>
</ol>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><ol>
<li><p>函数声明有一个重要的特征，就是函数声明提升，意思是在代码执行之前读取函数声明。函数表达式没有这一点，它只是一个普通的Function类型的实例。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show();<span class="comment">//hello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不要这样使用</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以这样使用</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">else</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为了防止函数名字发生改变而影响递归的使用，可以使用命名函数表达式，以下代码利用递归实现了阶乘：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * f(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">4</span>);<span class="comment">//24</span></span><br><span class="line">f;<span class="comment">//undefined，在外部不会访问到f这个变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于this的指代, 两句话:</p>
<ul>
<li>普通函数this指向函数的调用者, 如obj.fun()指向obj, fun()指向globalThis, fun.apply(obj)指向obj</li>
<li>箭头函数始终指向函数定义函数时所在的对象<br>匿名函数的话, 调用者是globalThis, 所以this指向globalThis. 下面是例子:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    fun0: fun,</span><br><span class="line">    fun1() &#123;</span><br><span class="line">        fun()</span><br><span class="line">    &#125;,</span><br><span class="line">    fun2() &#123;</span><br><span class="line">        (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fun0();<span class="comment">//obj</span></span><br><span class="line">obj.fun1();<span class="comment">//Window</span></span><br><span class="line">obj.fun2();<span class="comment">//obj</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>此部分参考了<a href="https://juejin.im/post/6844903511868571656">https://juejin.im/post/6844903511868571656</a></em></p>
</li>
<li><p>JavaScript没有块级作用域概念，可以使用函数来模拟：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ol>
<li><p>在浏览器中，<code>window</code>具有双重角色，它既是JavaScript访问窗口的一个接口，又是Global对象。</p>
</li>
<li><p>跨frame的instanceof操作符不管用，因为<code>top.Object != top.frames[0].Object</code>。</p>
</li>
<li><p><code>window.screenLeft</code>和<code>window.screenTop</code>分别表示<strong>浏览器窗口相对于屏幕</strong>左边缘和上边缘的位置。这两个值受操作系统缩放比例的影响。<br><code>window.outerWidth</code>和<code>window.outerHeight</code>分别表示<strong>浏览器窗口</strong>的宽度和高度，这两个值受操作系统缩放比例的影响。<br><code>window.innerWidth</code>和<code>window.innerHeight</code>分别表示<strong>包含滚动条的内部窗口</strong>宽度和高度，这两个值受操作系统缩放比例和浏览器缩放比例的影响。<br>html元素的<code>clientWidth</code>和<code>clientHeight</code>分别表示<strong>不包含滚动条的内部窗口</strong>宽度和高度，这两个值受操作系统缩放比例和浏览器缩放比例的影响。<br><code>window.devicePixelRatio</code>表示物理像素分辨率和CSS像素分辨率之比，即显示效果的放大倍数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Windows操作系统的缩放比例是1.24，浏览器的缩放比例是1.25</span></span><br><span class="line"><span class="comment">//在浏览器最大化时</span></span><br><span class="line"><span class="comment">//显示器分辨率为1920*1080</span></span><br><span class="line"><span class="built_in">window</span>.screenLeft;<span class="comment">//0</span></span><br><span class="line"><span class="number">1920</span> / <span class="built_in">window</span>.outerWidth;<span class="comment">//约1.24</span></span><br><span class="line"><span class="built_in">window</span>.outerWidth / <span class="built_in">window</span>.innerWidth;<span class="comment">//约1.25</span></span><br><span class="line"><span class="built_in">window</span>.innerWidth - <span class="built_in">document</span>.documentElement.clientWidth;<span class="comment">//13，指上下滚动条的CSS像素宽度为13</span></span><br><span class="line"><span class="built_in">window</span>.devicePixelRatio;<span class="comment">//约1.55，即1.24*1.25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开新标签页：<code>window.open(url)</code>，本页面加载其他网址：<code>window.open(url, &#39;_self&#39;)</code>，弹出窗口：<code>window.open(url, true)</code>。</p>
</li>
<li><p>使用<code>prompt(question, defaultAnswer)</code>方法可以弹出文本对话框。</p>
</li>
<li><p><code>location</code>对象既属于<code>window</code>，又属于<code>document</code>，也就是说<code>window.location === document.location</code>。</p>
</li>
<li><p>可以通过修改<code>location</code>对象的属性来改变当前页面地址，<code>location</code>对象的属性如下：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hash</td>
<td align="center"><code>&#39;#contents&#39;</code></td>
</tr>
<tr>
<td align="center">host</td>
<td align="center"><code>&#39;www.baidu.com:443&#39;</code></td>
</tr>
<tr>
<td align="center">hostname</td>
<td align="center"><code>&#39;www.baidu.com&#39;</code></td>
</tr>
<tr>
<td align="center">href</td>
<td align="center"><code>&#39;https://www.baidu.com:443/content&#39;</code></td>
</tr>
<tr>
<td align="center">pathname</td>
<td align="center"><code>&#39;/content&#39;</code></td>
</tr>
<tr>
<td align="center">port</td>
<td align="center"><code>443</code></td>
</tr>
<tr>
<td align="center">protocol</td>
<td align="center"><code>&#39;https:&#39;</code></td>
</tr>
<tr>
<td align="center">search</td>
<td align="center"><code>&#39;?query=abc&#39;</code></td>
</tr>
</tbody></table>
</li>
<li><p>重新加载页面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">locaiton.reload();<span class="comment">//重新加载（有可能从缓存加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>);<span class="comment">//从服务器重新加载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想让用户不能返回之前的网页，可以使用<code>location.replace(url)</code>方法。</p>
</li>
<li><p>出于安全考虑，开发者无法获得用户浏览过的url，但是可以在不知道url的情况下使用<code>window.histiry</code>对象实现前进和后退：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);<span class="comment">//后退一页</span></span><br><span class="line">history.go(<span class="number">2</span>);<span class="comment">//前进两页</span></span><br><span class="line">history.go(<span class="string">&#x27;baidu.com&#x27;</span>);<span class="comment">//跳转到最近的‘baidu.com’页面</span></span><br><span class="line">history.length === <span class="number">0</span>;<span class="comment">//这是当前用户打开窗口后的第一个页面</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ol>
<li><p>通过一个节点的<code>nodeType</code>属性, 可以获得节点的类型, 详情如下:</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Node.ELEMENT_NODE</td>
<td align="center">1</td>
<td align="center">元素节点</td>
</tr>
<tr>
<td align="center">Node.TEXT_NODE</td>
<td align="center">3</td>
<td align="center">文本节点</td>
</tr>
<tr>
<td align="center">Node.COMMENT_NODE</td>
<td align="center">8</td>
<td align="center">注释节点</td>
</tr>
<tr>
<td align="center">Node.DOCUMENT_NODE</td>
<td align="center">9</td>
<td align="center">Document节点, 一般是html节点和DOCTYPE节点的父节点</td>
</tr>
<tr>
<td align="center">Node.DOCUMENT_TYPE_NODE</td>
<td align="center">10</td>
<td align="center">DOCTYPE节点</td>
</tr>
<tr>
<td align="center">Node.DOCUMENT_FRAGMENT_NODE</td>
<td align="center">11</td>
<td align="center">文档片段节点, 虚拟DOM, 不在真实DOM中</td>
</tr>
</tbody></table>
</li>
<li><p>NodeList是一组有序的节点，有length属性，可以通过[]访问其值，但是它不是Array的实例。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">Array</span>.prototype.slice.call(aNodeList, <span class="number">0</span>);<span class="comment">//将NodeList转换成数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Node类型的一些方法：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.appendChild(newChild);</span><br><span class="line">parent.insertBefore(newChild, anotherChild);</span><br><span class="line">parent.replaceChild(newChild, anotherChild);</span><br><span class="line">parent.removeChild(child);</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>document.documentElement</code>或<code>document.lastChild</code>访问&lt;html&gt;对象，使用<code>document.body</code>访问&lt;body&gt;对象，使用<code>document.head</code>访问&lt;head&gt;对象。</p>
</li>
<li><p>使用<code>document.createElement()</code>创建元素节点，使用<code>document.createTextNode()</code>创建文本节点，使用<code>textNode.nodeValue</code>获得文本节点的文本。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">ele.appendChild(txt);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ele);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body.lastElementChild.firstChild.nodeValue);<span class="comment">//hello!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>document.querySelector()</code>和<code>document.querySelectorAll()</code>方法均接受一个CSS选择符，分别返回匹配的第一个元素和所有元素的NodeList。</p>
</li>
<li><p>关于Node之间的父子兄弟关系, <code>parentElement</code> <code>children</code> <code>firstElementChild</code> <code>lastElementChild</code> <code>previousElementSibling</code> <code>nextElementSibling</code>系列仅会考虑元素节点, 即nodeValue为1的Node; <code>parentNode</code> <code>childNodes</code> <code>firstChild</code> <code>lastChild</code> <code>previousSibling</code> <code>lastSibling</code>系列会考虑所有类型节点, 包括文本节点, Document节点等.</p>
</li>
<li><p>Node的class操作可以不使用<code>className</code>，而使用<code>classList</code>，<code>classList</code>是<code>DOMTokenList</code>的实例，有下列方法：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ele.classList.add(<span class="string">&#x27;some-class&#x27;</span>);</span><br><span class="line">ele.classList.remove(<span class="string">&#x27;some-class&#x27;</span>);</span><br><span class="line">ele.classList.contains(<span class="string">&#x27;some-class&#x27;</span>);</span><br><span class="line">ele.clsssList.toggle(<span class="string">&#x27;some-class&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于焦点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ele.focus();<span class="comment">//使该元素获取焦点</span></span><br><span class="line">ele.blur();<span class="comment">//使该元素失去焦点</span></span><br><span class="line">ele.hasFocus();<span class="comment">//测试该元素是否获取了焦点</span></span><br><span class="line"><span class="built_in">document</span>.activeElement;<span class="comment">//取得当前获取焦点的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了&lt;meta&gt;外，也可以直接使用<code>document.charset</code>设置字符集，该值默认为<code>&#39;UTF-16&#39;</code>。</p>
</li>
<li><p><code>ele.outerHTML</code>会返回包括自身的HTML代码。</p>
</li>
<li><p><code>ele.scrollIntoView()</code>方法可以使元素置于视口中。</p>
</li>
<li><p>DOM继承关系图<br><img src="./DOM_inheritance.png" alt="DOM继承关系图"></p>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol>
<li><p>JavaScript和HTML之间的交互是通过<strong>事件</strong>实现的，事件的接收顺序叫做事件流。IE的事件流是事件冒泡，即从最具体的节点开始，一直到顶层的document；Netscape的事件流是事件捕获，即从最顶层的document开始，到最具体的那个节点。“DOM2级事件”规定的事件流包括了上述两类，为事件捕获、处于目标阶段和事件冒泡三个阶段。</p>
</li>
<li><p>使用html事件处理程序时 <code>this</code>指代当前的节点。不仅如此，在html事件处理程序中，还扩充了作用域，它扩充了<code>this</code> <code>document</code>作用域，如果这是个表单输入元素（<code>input</code>），它还扩充了<code>this.form</code>作用域。这样一来，访问节点和节点的属性就可以像访问局部变量一样方便了。</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sam&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clickme&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(username.value)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- sam --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用DOM0级事件处理程序时<code>this</code>指代当前的节点，且会传入event参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    btn.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;clickme&#x27;</span>));</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(btn);</span><br><span class="line">    btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.target === <span class="built_in">this</span>);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">   &gt; 当然在Vue中，html中的`</span>$event<span class="string">`等同于`</span>event<span class="string">`，如果html中不传参，只写响应函数的名字，会自动传入`</span>$event<span class="string">`；</span></span><br><span class="line"><span class="string">   &gt; js部分，this最终指代Vue实例，不指代事件发生的元素，所以`</span><span class="built_in">this</span>.value<span class="string">` `</span><span class="built_in">this</span>.$event<span class="string">`这种访问方式不起作用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. 使用DOM2级事件处理程序时`</span><span class="built_in">this</span><span class="string">`指代当前节点，且会传入event参数。函数第3个布尔值为`</span><span class="literal">true</span><span class="string">`代表在事件捕获阶段接收事件，为`</span><span class="literal">false</span><span class="string">`代表在事件冒泡阶段接收事件，默认值为`</span><span class="literal">false</span><span class="string">`。在target节点上，无所谓捕获和冒泡，触发顺序受其注册顺序影响；在非target节点上，当然是先捕获后冒泡。   </span></span><br><span class="line"><span class="string">此外，添加和移除的handler函数需为同一个函数，即`</span>handlerAdd === handlerRemove<span class="string">`，这样才能有效地移除handler。</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    btn.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;clickme&#x27;</span>));</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(btn);</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;body click, event bubbling&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;body click, event capturing&#x27;</span>)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn click, event bubbling&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn click, event capturing&#x27;</span>)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    body click, event capturing</span></span><br><span class="line"><span class="comment">    btn click, event bubbling</span></span><br><span class="line"><span class="comment">    btn click, event capturing</span></span><br><span class="line"><span class="comment">    body click, event bubbling</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下表为DOM事件对象的一些属性</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">detail</td>
<td align="center">Intenger</td>
<td align="center">事件处理的细节信息</td>
</tr>
<tr>
<td align="center">eventPhase</td>
<td align="center">Intenger</td>
<td align="center">1捕获2处于目标3冒泡</td>
</tr>
<tr>
<td align="center">preventDefault()</td>
<td align="center">Function</td>
<td align="center">取消默认行为</td>
</tr>
<tr>
<td align="center">stopPropagation()</td>
<td align="center">Function</td>
<td align="center">阻止事件的进一步冒泡或捕获</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">Element</td>
<td align="center">事件所在元素</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">String</td>
<td align="center">事件触发的类型</td>
</tr>
</tbody></table>
</li>
<li><p>一些典型的事件</p>
<ul>
<li>UI事件（BOM事件）<ul>
<li>load</li>
<li>scroll</li>
<li>resize</li>
</ul>
</li>
<li>焦点事件<ul>
<li>focusin</li>
<li>focusout</li>
</ul>
</li>
<li>鼠标事件<ul>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>dblclick</li>
<li>mouseover</li>
<li>mouseout</li>
<li>mousemove</li>
<li>mousewheel</li>
</ul>
</li>
<li>键盘事件<ul>
<li>keydown</li>
<li>keypress</li>
<li>keyup</li>
</ul>
</li>
<li>触摸事件<ul>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
</ul>
</li>
</ul>
</li>
<li><p>所谓focus和blur不支持冒泡，是指这些事件不会触发“事件冒泡”，但是仍然会触发“处于目标阶段”。下面为使用<code>addEventListener</code>方法（DOM2级事件处理程序）监听事件的实例：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DOM中有一个id为&#x27;ipt&#x27;的input元素</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ipt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.body;</span><br><span class="line">i.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;input focus&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body focus, capture&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body focus, bubbling&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">i.focus();<span class="comment">//依次显示 body focus, capture; input focus</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DOM中有一个id为&#x27;ipt&#x27;的input元素</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ipt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.body;</span><br><span class="line">i.addEventListener(<span class="string">&#x27;focusin&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;input focus&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;focusin&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body focusin, capture&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;focusin&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body focusin, bubbling&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">i.focus();<span class="comment">//依次显示 body focusin, capture; input focusin; body focusin, bubbling</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DOM中有一个id为&#x27;ipt&#x27;的input元素</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ipt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.body;</span><br><span class="line">i.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;input mouseover&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body mouseover, capture&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body mouseover, bubbling&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//将鼠标从body移至input，依次显示 body mouseover, capture; input mouseover; body mouseover, bubbling</span></span><br><span class="line"><span class="comment">//将鼠标从input移出至body，依次显示 body mouseover, capture; body mouseover, bubbling</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>clientX是指点相对于浏览器窗口的位置，pageX是指点相对于页面的位置（如果一个页面特别宽，那这个值的最大值也会很大），screenX是指点相对于屏幕的位置。</p>
</li>
</ol>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ol>
<li><p>使用document.forms获得所有表单，这是一个HTMLCollection的实例，可以通过索引值或名称访问到具体的表单。</p>
</li>
<li><p>在<code>type=submit</code>的input元素或button元素上点击或回车，可以提交表单，提交表单之前会触发form的<code>submit</code>事件。但是直接使用<code>form.submit()</code>方法提交表单，是不会触发这一事件的。reset功能同理，但是使用<code>form.reset()</code>方法重置表单会触发<code>reset</code>事件。</p>
</li>
<li><p>通过form.elements访问表单中的字段，既可以通过名字也可以通过索引值访问具体的某个或某些元素。通过索引值访问到的一定是单个元素，通过名字访问到的有可能是单个元素，也有可能是多个同名的Nodelist。</p>
</li>
<li><p>input和textarea文本框都支持<code>select()</code>方法，该方法可以选中文本框中的所有文本。无论是用户选择了文本，还是调用<code>select()</code>方法选择了文本，都会触发<code>select</code>事件。用户选择的部分，可以使用<code>selectionStart</code>和<code>selectionEnd</code>来获得。如果想通过代码选择部分文本，可以使用<code>setSelectionRange(start, end)</code>方法。</p>
</li>
<li><p>剪贴板事件主要有<code>copy</code> <code>cut</code> <code>paste</code>，Chrome、Safari和Firefox都<strong>只能在处理剪贴板事件时</strong>才能访问和设置剪贴板内容，如下所示：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncopy = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;text you copied&#x27;</span>);<span class="comment">//无论用户复制什么，剪贴板内容不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.oncut = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.clipboardData.clearData();<span class="comment">//无论用户剪切什么，剪贴板都为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onpaste = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.clipboardData.getData(<span class="string">&#x27;text/plain&#x27;</span>);<span class="comment">//获取剪贴板内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>selectbox.options[n].text</code>和<code>selectbox.options[n].value</code>获取选择框（select）选项的文本和值，使用<code>selectbox.appendChild(new Option(text, value))</code>添加选项。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>部分ES6知识</title>
    <url>/blog/2020/08/12/%E9%83%A8%E5%88%86ES6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本文包含ES6(ES2015~ES2020)的let&amp;const, 解构赋值, Symbol, 异步操作和Modlue部分, 是阅读<a href="https://es6.ruanyifeng.com/">ECMAScript6入门教程(阮一峰)</a>记下的笔记, 记录下了一些我认为有价值的知识, 并不是ES6的教程.</p>
<a id="more"></a>

<h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><ol>
<li><p><code>let</code>的出现确定了块级作用域, 若块级作用域A内函数B访问局部变量, 那么该函数B的作用域链包含块级作用域A, B函数类似于闭包. 下面的例子中, for循环父作用域中嵌套了5个子作用域, 每个作用域内i值不同, 所以每个函数中i值也不同. 如过使用var, 也想达到这样的效果, 就要使用闭包了. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]();<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code>不像var和function那样存在变量提升, 但是存在“暂时性死区”, 即在一个作用域内, 只要使用<code>let</code>声明了变量, 那在声明之前变量是不能使用的.<br>其实实际的区别如下图, 图片来自<a href="https://zhuanlan.zhihu.com/p/28140450">https://zhuanlan.zhihu.com/p/28140450</a><br> <img src="./four_defenitions.png" alt="四种定义方式的区别"></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var的声明提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> a;<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//function的声明提升</span></span><br><span class="line">b();<span class="comment">//2</span></span><br><span class="line"><span class="keyword">typeof</span> b;<span class="comment">//function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="comment">//let的暂时性死区</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">typeof</span> c;<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//测试未声明变量</span></span><br><span class="line"><span class="built_in">console</span>.log(d);<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">typeof</span> d;<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于环境导致的差异太大, 所以优先使用<code>let</code>和函数表达式, 避免在块级作用域内使用函数声明和<code>var</code>. </p>
</li>
<li><p>块级作用域必须有大括号, 没有的话就不能使用<code>let</code>. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) <span class="keyword">var</span> a = <span class="number">1</span>;<span class="comment">//没问题</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) <span class="keyword">let</span> b = <span class="number">2</span>;<span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和<code>let</code>一样, <code>const</code>不允许重复声明, 也存在暂时性死区. </p>
</li>
<li><p>由于浏览器的顶层对象是<code>window</code>/<code>self</code>, Node.js的顶层对象是<code>global</code>；在全局环境中<code>this</code>返回顶层对象, 但是Node.js模块和ES6模块中<code>this</code>指当前模块；非对象函数的<code>this</code>指向顶层对象, 但是严格模式下指向<code>udefined</code>. 所以顶层对象获取比较复杂. ES2020规定了<code>globalThis</code>作为顶层对象, 使顶层对象的获取更加方便. </p>
</li>
</ol>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ol>
<li><p>如果等号右边是可遍历的结构, 就可以使用数组的解构赋值. 数组的解构赋值是按次序, 由位置决定赋值的. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , [a], b] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];<span class="comment">//a: 3, b: undefined</span></span><br><span class="line"><span class="keyword">let</span> [c, ...d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//c: 1, d: [2, 3]</span></span><br><span class="line"><span class="keyword">let</span> [e] = <span class="literal">null</span>;<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组解构赋值可以设置默认值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [<span class="literal">undefined</span>];<span class="comment">//a: 1, b: 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果等号右边的值是对象或可以转换成对象, 就可以使用对象的解构赋值. 对象的解构赋值是按照相同属性名赋值的. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, <span class="attr">a</span>: &#123;<span class="attr">b</span>: c&#125;, d&#125; = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;, <span class="attr">d</span>: <span class="number">2</span>&#125;;<span class="comment">//a: &#123;b: 1&#125;, b: undefined, c: 1, d: 2</span></span><br><span class="line"><span class="keyword">let</span> &#123;sin, cos, tan&#125; = <span class="built_in">Math</span>; <span class="keyword">let</span> &#123;log&#125; = <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: e&#125; = [<span class="number">1</span>, <span class="number">2</span>];<span class="comment">//e: 1, 数组是对象, 所以可以这样使用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>‘对象解构赋值可以设置默认值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span> : b = <span class="number">1</span>&#125; = &#123;&#125;;<span class="comment">//a: undefined, b: 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于已经声明的变量, 赋值时不要将大括号写在行首, 必要时把赋值语句用括号括起来：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">(&#123;a&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串可以转换成String类型的对象, 所以也可以使用解构赋值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&#x27;es6&#x27;</span>;<span class="comment">//a: &#x27;e&#x27;, b: &#x27;s&#x27;, c: &#x27;6&#x27;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: d, <span class="attr">length</span>: l&#125; = <span class="string">&#x27;es6&#x27;</span>;<span class="comment">//d: &#x27;e&#x27;, l: 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的结构赋值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a: c = <span class="number">1</span>, b = <span class="number">2</span>&#125; = &#123;a: <span class="number">3</span>, b: <span class="number">4</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c, b);</span><br><span class="line">&#125;</span><br><span class="line">fun(&#123;<span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">6</span>&#125;);<span class="comment">//5 6</span></span><br><span class="line">fun(&#123;<span class="attr">a</span>: <span class="number">5</span>&#125;);<span class="comment">//5 2</span></span><br><span class="line">fun();<span class="comment">//3 4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ol>
<li><p>在ES6中, Symbol类型是一种基本数据类型, 表示独一无二的值. Symbol类型不能和其他类型运算, 但是可以转换成字符串和布尔值. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s0 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">s0 + <span class="number">1</span>;<span class="comment">//TypeError</span></span><br><span class="line">s1 + <span class="string">&#x27;1&#x27;</span>;<span class="comment">//TypeError</span></span><br><span class="line"><span class="built_in">String</span>(s0);<span class="comment">//&#x27;Symbol()&#x27;</span></span><br><span class="line"><span class="built_in">String</span>(s1);<span class="comment">//&#x27;Symbol(s)&#x27;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s0);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(s1);<span class="comment">//true</span></span><br><span class="line">s0.description;<span class="comment">//undefined</span></span><br><span class="line">s1.description;<span class="comment">//&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将Symbol类型用作对象属性名, 并且遍历：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_GREEN = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_RED = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [COLOR_GREEN]: <span class="string">&#x27;#0f0&#x27;</span>,</span><br><span class="line">    [COLOR_RED]: <span class="string">&#x27;#f00&#x27;</span>,</span><br><span class="line">    blue: <span class="string">&#x27;#00f&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj);<span class="comment">//[&#x27;blue&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);<span class="comment">//[Symbol(), Symbol()]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownkeys(obj);<span class="comment">//[&#x27;blue&#x27;, Symbol(), Symbol()]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Symbol.for()</code>方法, 可以在全局环境下, 用字符串对Symbol类型变量进行登记. 使用<code>Symbol.keyfor()</code>方法, 可以获得已在全局登记的Symbol类型变量的标识值. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s0;</span><br><span class="line">&#123;</span><br><span class="line">    s0 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = Symnol.for(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">s0 === s1;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyfor(s0);<span class="comment">//&#x27;s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">s2 === s3;<span class="comment">//false</span></span><br><span class="line">s0 === s2;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyfor(s2);<span class="comment">//ndefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6提供了11个内置的Symbol值, 指向语言内部使用的方法, 这里以<code>Symbol.replace</code>为例介绍：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str.replace(from, to) 等同于 from[Symbol.replace](str, to)</span></span><br><span class="line"><span class="keyword">let</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="string">&#x27;123&#x27;</span>.replace(x, <span class="string">&#x27;456&#x27;</span>);<span class="comment">//[&#x27;123&#x27;, &#x27;456&#x27;]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ol>
<li><p>Promise是异步编程的一种解决方案, 一个Promise对象代表一个异步操作, 它有3种状态：<code>pending(进行中)</code> <code>fufilled(已成功)</code> <code>rejected(已失败)</code>, 后面两种统称为<code>resolved(已定型)</code>, 但是一般我们用<code>resolved(已定型)</code>代表<code>fufilled(已成功)</code>.</p>
<p> 在详述Promise之前, 需要明确<code>事件循环(Event Loop)</code>. <code>事件循环(Event Loop)</code>在浏览器和Node.js中的实现是有一些不同的, 参考<a href="https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B">这里</a>来了解浏览器的实现, 参考<a href="https://sien75.github.io/blog/2020/09/08/Node-js%E5%9F%BA%E7%A1%80/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop">这里</a>来了解Node.js的实现.</p>
</li>
<li><p>Promise新建后会立即执行, 其<code>then</code>方法会按照<code>Event Loop</code>执行.Promise对象的<code>then</code>方法接受2个参数, 第一个会在Promise对象的<code>fufilled</code>状态时执行, 第二个会在其<code>rejected</code>状态时执行. 不过不建议这种写法, 一般<code>then</code>处理<code>fufilled</code>状态, <code>catch</code>处理<code>rejected</code>状态.</p>
<p>在下面的代码中, p2会返回一个Promise对象, 所以其状态失效, 改为由p1决定. 所以, 代码执行后的第3秒, 会显示”Error: fail”. 错误会沿着异步操作链, 直到被第一个<code>catch</code>捕获. 如果没有<code>catch</code>捕获, 那该错误会成为未捕获错误, 但不会中断程序执行. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.prototype.finally()</code>方法, 不管异步操作最后抛出什么状态, 都会执行该函数回调函数内的操作, 并最终返回一个Promise对象. 如果前一个Promise对象有resolve值, 该Promise对象也有相应的resolve值; 如果前一个Promise对象有reject值, 那该Promise对象也有相应的reject值. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.all</code>方法用于将多个Promise对象合为一个新对象. 只有所有的对象都变为<code>fufilled</code>状态时, 新对象才会变为<code>fufilled</code>状态; 当其中一个对象状态变为<code>rejected</code>状态时, 新对象会变为<code>rejected</code>状态. 如果传入参数不是Promise对象, 会使用<code>Promise.resolve()</code>将其转换为Promise对象. (下面的例子中, p0, p1, p3状态都是<code>fufilled</code>, p2状态是<code>rejected</code>.)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p0 = <span class="built_in">Promise</span>.resolve(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="number">3</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"><span class="built_in">Promise</span>.all([p0, p1])</span><br><span class="line">.then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);<span class="comment">//[0, 1], 第一个显示</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p0, p2])</span><br><span class="line">.then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);<span class="comment">//2, 第三个显示</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p0, p3])</span><br><span class="line">.then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);<span class="comment">//[0, 1], 第二个显示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.race()</code>方法用于将多个Promise对象合为一个新对象. 只要其中有一个对象的状态改变了, 新对象就跟着改变. 如果传入参数不是Promise对象, 会使用<code>Promise.resolve()</code>将其转换为Promise对象. 该方法可以用于下面的设置最大延迟时间的操作:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">    fetch(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">]);</span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.allSettled()</code>方法用于将多个Promise对象合为一个新对象. 只有其中所有对象的状态改变了, 新对象才跟着改变. 如果传入参数不是Promise对象, 会使用<code>Promise.resolve()</code>将其转换为Promise对象. 不关心异步操作结果, 只关心这些操作有没有结束, 就可以用这个方法.<br><code>Promise.any()</code>方法现在还未纳入标准(2020年), 它用于将多个Promise对象合为一个新对象. 只要有对象都变为<code>fufilled</code>状态时, 新对象就会变为<code>fufilled</code>状态; 当所有对象状态变为<code>rejected</code>状态时, 新对象会变为<code>rejected</code>状态. 如果传入参数不是Promise对象, 会使用<code>Promise.resolve()</code>将其转换为Promise对象. </p>
</li>
<li><p><code>Promise.resolve()</code>用于将现有变量转换为状态为<code>fufilled</code>的Promise类型的变量.</p>
<ul>
<li>如果现有变量是一个Promise变量, 则原样返回</li>
<li>如果现有变量不是Promise变量, 则返回一个resolve值为该变量值的Promise对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(v);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(v));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Promise.reject()</code>用于将现有变量转换为状态为<code>rejected</code>Promise类型的变量.</p>
<ul>
<li>如果现有变量是一个Promise变量, 则原样返回</li>
<li>如果现有变量不是Promise变量, 则返回一个reject值为该变量值的Promise对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(v);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; reject(v));</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><ol>
<li><p>Generator函数是异步编程的一种解决方案. 调用Generator函数并不会执行函数中的代码, 该函数返回的是一个继承自该函数原型对象的对象, 它们的关系如下图. 我们先定义一个Generator函数:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">2</span> * a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> <img src="./relation.png" alt="生成器函数和新生成对象的关系"><br> 使函数内代码执行有以下几种方法(有遍历器接口就可以):</p>
<ul>
<li>调用<code>g.next()</code>方法.每次调用该方法, 函数内代码都会由上次执行的位置开始, 直到遇到yield表达式, 求出值为止. 以上面函数为例, 第一次调用, 会执行<code>yield 1</code>表达式, 并且返回这一值. <code>g.next()</code>方法内的参数会作为上一次yield表达式的值. 以上面的函数为例, 第二次调用<code>g.next(3)</code>, 首先用<code>3</code>替代<code>yield 1</code>这个表达式, 再把<code>3</code>赋给<code>a</code>, 再执行<code>yield 2 * a</code>表达式, 把结果<code>6</code>返回给调用函数, 然后暂停.  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next();<span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">3</span>);<span class="comment">//&#123;value: 6, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">4</span>);<span class="comment">//&#123;value: 4, done: true&#125;</span></span><br><span class="line">g.next();<span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>for...of</code>循环. 由于<code>for...of</code>循环会在yield表达式返回值的<code>&#39;done&#39;</code>字段为<code>true</code>时就停止, 所以不会包含return语句的值.   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> gen()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">NaN</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>...</code>扩展运算符. 效果同<code>for...of</code>.  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...gen());<span class="comment">//1 NaN</span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>Aray.from()</code>. 效果同<code>for...of</code>.  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(gen());<span class="comment">//[1, NaN]</span></span><br></pre></td></tr></table></figure></li>
<li>使用解构赋值. 效果同<code>for...of</code>.  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = gen();</span><br><span class="line">x;<span class="comment">//1</span></span><br><span class="line">y;<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果想让Generator函数返回的遍历器抛出错误, 可以使用<code>Generator.prototype.throw()</code>方法. 使用该方法抛出的错误是遍历器的内部错误, 可以在函数内部捕获, 如果函数内部没有捕获, 那么会在函数外部捕获. 如果错误没有被捕获, 会发生错误, 程序中止.(Promise内发生未捕获错误不会中止程序)   <code>Generator.prototype.throw()</code>方法调用会自动执行一次<code>Generator.prototype.next()</code>方法.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;inner&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    g.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="number">0</span>));</span><br><span class="line">    g.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;outer&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inner 0</span></span><br><span class="line"><span class="comment">//outer 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想让Generator函数提前结束, 可以使用<code>Generator.prototype.return()</code>方法. 调用该方法后, 函数后面的语句都不会执行了. 如果有<code>try...finally</code>语句, 那就会执行finally代码块.(<code>try...finally</code>只有配合<code>Generator.prototype.return()</code>才有效)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next();<span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">g.return();<span class="comment">//&#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next();<span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想在Generator函数内部再使用Generator函数, 可以使用<code>yield *</code>表达式. 事实上, 只要有遍历器接口, 都可以使用该表达式.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inner = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;inner0&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;inner1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * inner();</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="string">&#x27;array&#x27;</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> inner();<span class="comment">//作为对比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> outer()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inner0</span></span><br><span class="line"><span class="comment">inner1</span></span><br><span class="line"><span class="comment">array</span></span><br><span class="line"><span class="comment">outer</span></span><br><span class="line"><span class="comment">inner(一个遍历器对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>yield *</code>表达式, 将嵌套数组转变成按顺序的一维数组:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line"><span class="keyword">let</span> unfold = <span class="function"><span class="keyword">function</span>* <span class="title">fun</span> (<span class="params">tree</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> t <span class="keyword">of</span> tree) &#123;</span><br><span class="line">            <span class="keyword">yield</span> * fun(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [...unfold(tree)];</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将Generator函数作为对象的属性, 可以按照以下格式简写:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * fun () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想使用Generator函数的this, 也就是说使新建的对象拿到一些定义的数据, 可以采用以下原型模式来解决:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen.call(gen.prototype);</span><br><span class="line">g.next();</span><br><span class="line">g.a;<span class="comment">//1</span></span><br><span class="line"><span class="comment">//或者这样</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">gen.prototype.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line">g.a;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>即把需要定义的数据放到<code>gen</code>函数的原型对象上, 由于遍历器对象<code>g</code>继承自<code>gen</code>函数的原型对象, 所以必然可以访问到新定义的对象.</p>
</li>
<li><p>使用Generator函数实现状态机:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> day = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> days = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> days[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line">day.next().value;<span class="comment">//Mon</span></span><br><span class="line">day.next().value;<span class="comment">//Tue</span></span><br></pre></td></tr></table></figure>
<p>如果使用一般的函数或者对象, 都需要一个保存状态的变量, Generator函数由于自带暂停机制, 可以保存当前状态, 所以是最优雅的状态机实现方式.</p>
</li>
<li><p>关于错误处理, 一般情况下使用<code>try...catch</code>语句来处理, 如果是Promise对象, 还可以使用其<code>catch</code>方法或者<code>then</code>方法来处理.</p>
</li>
</ol>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><ol>
<li><p>async函数是Generator函数的语法糖. 和Generator函数相比, async函数内置执行器, 也就是说它不用使用<code>next</code>方法, 就可以自动执行函数内操作; Generator函数返回的是遍历器对象, 而async函数返回的是Promise对象, 更有利于异步操作. 下面是async函数的基本用法:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sleep = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, t)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">exe</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);<span class="comment">//延迟1秒</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>async函数内部return返回的值, 会作为返回的Promise对象的then方法回调函数参数, 如果使用await调用的话就是await语句的返回值; async函数内部的错误, 会被catch捕获.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sleep = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, t)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> getData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;data&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> errorOccurs = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">throw</span>(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一种用法</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> getData());<span class="comment">//data</span></span><br><span class="line">&#125;());</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> errorOccurs();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);<span class="comment">//Error: error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">//第二种用法</span></span><br><span class="line">getData().then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);<span class="comment">//data</span></span><br><span class="line">errorOccurs().then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);<span class="comment">//Error: error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用async函数和<code>Promise.all</code>实现多任务并发执行:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tasks = [<span class="function">() =&gt;</span> &#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)&#125;, ...];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks.map(<span class="function"><span class="params">task</span> =&gt;</span> task()));</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tasks = [...];</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> r <span class="keyword">of</span> tasks.map(<span class="function"><span class="params">task</span> =&gt;</span> task()) ) &#123;</span><br><span class="line">            result.push(<span class="keyword">await</span> r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//传统写法, 实现同样的效果</span></span><br><span class="line"><span class="keyword">let</span> tasks = [...];</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">let</span> finished = <span class="number">0</span>, ifError = <span class="literal">false</span>;</span><br><span class="line">tasks.forEach(<span class="function">(<span class="params">task, i</span>) =&gt;</span> &#123;</span><br><span class="line">    task().then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = r;</span><br><span class="line">        finished++;</span><br><span class="line">        <span class="keyword">if</span>(finished === tasks.length &amp;&amp; !ifError) <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        ifError = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ol>
<li><p>使用<code>export</code>规定模块的对外接口(模块中顶层this为<code>undefined</code>):</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;;</span><br><span class="line"><span class="comment">//第三种写法</span></span><br><span class="line"><span class="keyword">var</span> _a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;_a <span class="keyword">as</span> a&#125;;</span><br><span class="line"><span class="comment">//export需要与模块内部变量建立一一对应关系, 所以下面的写法是错误的</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="keyword">export</span> a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>import</code>加载模块:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//不能改写接口, 下面错误</span></span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果接口是对象,是可以改其属性的</span></span><br><span class="line">b.prop = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//不能使用表达式和变量, 下面错误</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;1&#x27;</span> &#125; <span class="keyword">from</span> name;</span><br><span class="line"><span class="comment">//多import只会执行一次</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//import有变量的提升(声明, 初始化和赋值全提升)</span></span><br><span class="line">a();</span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块的整体加载:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> all <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//不允许对all进行修改操作, 下面均错误</span></span><br><span class="line">all = &#123;&#125;;</span><br><span class="line">all.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>export default</code>命令, 可以无需知道接口名字, 直接进行引用:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面三种效果是等同的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="keyword">export</span> &#123; a <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">import</span> _a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//export default实际上是定义了一个叫做default的变量, 所以下面是错的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>export</code>和<code>import</code>可以混合使用, 不过这只是做了个转接, 并没有引入变量, 所以<strong>不能使用这些变量</strong>.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> all <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> all;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">import</span> def <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> def;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>import()</code>函数按需异步加载模块, <code>import()</code>返回的是一个Promise对象.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="keyword">default</span>&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">default</span>);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></li>
<li><p>浏览器加载模块, 除了可以使用<code>import</code>外, 也可以使用script标签异步加载(遇到后即下载脚本, 但不会等待执行, 会直接执行下面的同步代码).</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//下面这种是页面渲染完再执行</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./a.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//下面这种是脚本下载完就执行, 可能中断HTML解析(DOM树的构建)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./a.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//默认情况下脚本的下载和执行都会中断HTML解析, 而且也会等待下载和执行的过程</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 以下图片来自<a href="https://juejin.im/post/6844903745730396174">https://juejin.im/post/6844903745730396174</a><br> <img src="./script_meanings.png" alt="图例"><br> defer:<br> <img src="./defer.png" alt="defer"><br> async:<br> <img src="./async.png" alt="async"><br> default:<br> <img src="./default.png" alt="default"></p>
</li>
<li><p>ES6的模块是动态引用, 也就是说如果模块中的某个变量值发生了变化, 所有引用该模块的地方, 这个变量值都会变化.</p>
</li>
<li><p>由于Node.js有自己的CommonJS模块格式, 所以需要一些策略来对这两种模块加载方式进行区分.</p>
<ul>
<li><code>.cjs</code>的文件总是以CommonJS模块加载, <code>.mjs</code>的文件总是以ES6模块加载</li>
<li><code>package.json</code>文件的<code>type</code>字段为空或<code>commonjs</code>则<code>.js</code>文件以CommonJS模块加载, 如果<code>type</code>字段为<code>module</code>则<code>.js</code>文件以ES6模块加载</li>
</ul>
</li>
<li><p><code>package.json</code>有两个字段可以规定模块的入口文件: <code>main</code>和<code>exports</code>. 比较简单的模块, 可以只使用<code>main</code>字段:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module/package.json部分代码</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./app.js里面这样加载./node_modules/es-module/src/index.js文件</span></span><br><span class="line"><span class="keyword">import</span> esModule <span class="keyword">from</span> <span class="string">&#x27;es-module&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>复杂的模块, 可以使用<code>exports</code>字段, 它的优先级高于<code>main</code>字段:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module/package.json部分代码</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="string">&quot;./src/a.js&quot;</span>,</span><br><span class="line">        <span class="string">&quot;b_dir&quot;</span>: <span class="string">&quot;./src/b/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./app.js里面这样加载./node_modules/es-module/src/a.js文件</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;es-module/a&#x27;</span>;</span><br><span class="line"><span class="comment">// ./app.js里面这样加载./node_modules/es-module/src/b/index.js文件</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;es-module/b/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>exports</code>字段的别名如果是<code>.</code>就相当于<code>main</code>字段(主入口):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基础</title>
    <url>/blog/2020/08/24/HTTP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文为阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN文档中的HTTP部分</a>以及其他相关资料的笔记, 记录下了我认为关于HTTP的有价值的基础内容, 仅作为参考, 并不是教程类文章.</p>
<a id="more"></a>

<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p><em>本文参考了<a href="https://www.cnblogs.com/chenqf/p/6386163.html">https://www.cnblogs.com/chenqf/p/6386163.html</a>, 这篇文章写的非常棒!</em></p>
<ol>
<li><p>缓存分为<strong>强制缓存</strong>和<strong>对比缓存</strong>.</p>
<ul>
<li>强制缓存如果生效, 那么就不需要向服务器发送请求, 直接使用缓存内容</li>
<li>对比缓存机制下总是会向服务器发送请求, 服务器会进行验证, 并决定返回内容</li>
<li>强制缓存优先级高于对比缓存, 强制缓存不生效时再使用对比缓存规则</li>
</ul>
</li>
<li><p><code>强制缓存</code>是通过时间来验证缓存内容是否过期的. HTTP1.0时期的<code>Expires</code>字段, 已被HTTP1.1时期的<code>Cache-Control</code>替代. 在第一次请求服务器时, 服务器响应头会通过<code>Cache-Control</code>来告知客户端缓存策略. <code>Cache-Control</code>字段主要有以下取值:</p>
<ul>
<li>max-age=n, 表示采用强制缓存, 且有效时间为n秒</li>
<li>no-cache, 使用对比缓存</li>
<li>no-store, 不缓存</li>
</ul>
</li>
<li><p><code>对比缓存</code>有以下两种方式来验证缓存内容是否过期:</p>
<ul>
<li><code>If-Modified-Since</code>, 客户端在请求头中带上上一次在服务器返回内容时<code>Last-Modified</code>的字段内容, 服务器验证在此时间之后内容是否有修改, 如有则返回新内容(200 OK), 如无则返回304 Not Modified</li>
<li><code>If-None-Match</code>, 客户端在请求头中带上上一次服务器返回内容时<code>Etag</code>的字段内容, 这是由服务器生成的对资源的唯一标识, 服务器使用这一标识验证相应内容是否有新版本, 如有则返回新内容(200 OK), 如无则返回304 Not Modified</li>
</ul>
</li>
<li><p>总的来说, 优先级上<code>强制缓存</code> &gt; <code>If-None-Match/Etag</code> &gt; <code>If-Modified-Since/Last-Modified</code>.</p>
<ul>
<li>如果存在强制缓存设置且生效, 则直接在缓存中获得内容, 不向服务器发送请求</li>
<li>如果强制缓存未设置或失效, 则使用对比缓存, 上一次服务器返回的HTTP头中若有<code>Etag</code>字段则用<code>If-None-Match/Etag</code>, 否则若有<code>Last-Modified</code>则用<code>If-Modified-Since/Last-Modified</code></li>
<li>如果未设置缓存机制, 则正常请求服务器内容</li>
</ul>
</li>
</ol>
<h2 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h2><p>Cookie主要用于会话管理, 个性化设置和浏览器行为跟踪, 由于Cookie有大小限制, 且浏览器每次请求都会带上Cookie数据造成额外开销, 所以Cookie已经不适合用作存储数据.</p>
<p>服务端设置Cookie:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly; Domain&#x3D;baidu.com; Path&#x3D;&#x2F;search; SameSite&#x3D;None</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li>未指定过期时间<code>Expires</code>则为会话Cookie, 窗口关闭自动删除; 设置了<code>Expires</code>是按照客户端的时间来计算的</li>
<li><code>Secure</code>标识是指该Cookie仅能在HTTPS请求中发送给服务端</li>
<li><code>HttpOnly</code>标识是指该Cookie无法通过<code>document.cookie</code>访问到, 可有效防止XSS攻击</li>
<li><code>Domain</code>标识指定后所有子域名都可以使用这一Cookie, 默认情况下不同子域名间是不能互相访问Cookie的</li>
<li><code>Path</code>标识设置后所有<code>/search</code>目录下的所有路径都会访问到Cookie值</li>
<li><code>SameSite=Lax</code>为浏览器默认值, 意思是跨域请求不带上该Cookie, 可有效防止CSRF攻击, 设为<code>None</code>则取消该限制</li>
</ul>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS(Cross-Origin Resource Sharing)跨域资源共享, 是一种机制, 使用额外的HTTP头来告诉浏览器和服务器, 控制跨域的HTTP请求.</p>
<ol>
<li><p>场景1: 简单请求. 所谓简单请求, 是指使用<code>GET</code> <code>POST</code> <code>HEAD</code>, 且只包含被允许的HTTP头, <code>Content-Type</code>只能是指定值的请求. 浏览器在请求时会带上如下HTTP头:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin: https:&#x2F;&#x2F;source.com</span><br></pre></td></tr></table></figure>
<p> 服务器核实这个域是否被允许, 如允许, 则返回内容中带有如下HTTP头:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *(或https:&#x2F;&#x2F;source.com)</span><br></pre></td></tr></table></figure>
<p> 如果不允许, 返回内容中是不包含这个HTTP头的, 并在浏览器中触发错误.</p>
</li>
<li><p>场景2: 复杂请求. 不满足简单请求的都是复杂请求, 浏览器会预先使用OPTION方法发送一个预检请求, 询问服务器是否允许:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin: https:&#x2F;&#x2F;source.com</span><br><span class="line">Access-Control-Request_method: PUT</span><br><span class="line">Access-Control-Headers: My-Header</span><br></pre></td></tr></table></figure>
<p> 如果服务器允许, 就会带上以下HTTP头:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;source.com</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT</span><br><span class="line">Access-Control-Allow-Headers: My-Header</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p> 其中<code>Access-Control-Max-Age: 86400</code>意思是在24小时之内不必为同样的请求再次发送预检请求.</p>
</li>
<li><p>场景3: 附带Cookie的请求. 当然, 要想跨域附带Cookie, 首先需要设置好<code>目标网站https://destination.com</code>Cookie的<code>SameSite: None</code>, 允许跨域请求带Cookie. 对于XHR请求来说, 附带Cookie的操作如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//other codes</span></span><br></pre></td></tr></table></figure>
<p> 这样请求中就会带上Cookie, 如果服务器允许, 则返回的请求中就会多出如下HTTP头:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="常见的HTTP响应代码"><a href="#常见的HTTP响应代码" class="headerlink" title="常见的HTTP响应代码"></a>常见的HTTP响应代码</h2><ul>
<li><code>200 OK</code>, 请求成功</li>
<li><code>301 Moved Permanently</code>, 请求的资源已被永久移至新位置</li>
<li><code>304 Not Modified</code>, 请求的资源没有更改</li>
<li><code>404 Not Found</code>, 请求的资源未发现</li>
<li><code>501 Not Implemented</code>, 服务器不支持此请求方法</li>
</ul>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML和CSS基础</title>
    <url>/blog/2020/08/23/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文包含了部分HTML, CSS的内容, 是阅读<a href="https://developer.mozilla.org/zh-CN/">MDN中文文档</a>的HTML和CSS部分, 以及<a href="https://www.sass.hk/guide/">Sass快速入门</a>做下的笔记, 不是教程, 不以总结全面为目标, 仅仅是记录下自己觉得有价值的点, 作为参考.</p>
<a id="more"></a>

<h2 id="关于HTML5"><a href="#关于HTML5" class="headerlink" title="关于HTML5"></a>关于HTML5</h2><p>所谓的HTML5, MDN上解释得很清楚: “它是一个新版本的HTML语言, 具有新的元素, 属性和行为. 另一方面它有更大的技术集, 允许构建更多样化和更强大的网站和应用程序. 这个集合有时称为HTML5和它的朋友们, 不过大多数时候仅缩写为一个词 HTML5.” 所以, 广义HTML5中的HTML含量并不是很多.</p>
<p>我觉得HTML5标准中很多都是浏览器方面的, 比如说离线存储, 性能集成, 设备访问这些; 而像新支持的WebSocket是属于网络方面的, HTML5提供了访问它的Web Api; 对像音频视频这些多媒体的支持, 以及像canvas图像编程的支持, 就都是具体的应用技术点了. 所以去掉不纯的, 剩下的关于HTML的也没多少, 我把拖放, 表单部分以及区块和段落元素放在这里了. 那些”HTML5的朋友们”, 而且比较重要的, 我就分别在其他领域总结了.</p>
<h2 id="HTML5拖放"><a href="#HTML5拖放" class="headerlink" title="HTML5拖放"></a>HTML5拖放</h2><p>考虑到我有可能要使用到SVG, 并且进行拖放, 所以我打算学习一下HTML5的拖放. 要使元素可拖放, 需要设置其<code>draggable</code>属性为<code>true</code>, 不过图片和链接默认下可拖放, 选中的文本也是默认可以拖放的.</p>
<p>被拖动的元素有以下事件:</p>
<ul>
<li>dragstart, 在元素拖动开始时触发</li>
<li>drag, 在元素拖动时触发</li>
<li>dragend, 在拖动完成时触发<br>目的地元素有以下事件:</li>
<li>dragenter, 被拖动元素进入时触发</li>
<li>dragover, 被拖动元素处于该元素中时触发</li>
<li>dragleave, 被拖动元素离开时触发</li>
<li>drop, 释放被拖动元素时触发</li>
</ul>
<p>把某一个元素(ele0)拖动到另一个元素(ele1)上面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ele0.ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.dataTransfer.setData(<span class="string">&#x27;Text&#x27;</span>, e.target.id);</span><br><span class="line">&#125;</span><br><span class="line">ele1.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();<span class="comment">//默认是不允许放置的</span></span><br><span class="line">&#125;</span><br><span class="line">ele1.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id = e.dataTransfer.getData(<span class="string">&#x27;Text&#x27;</span>);</span><br><span class="line">    e.target.appendChild(<span class="built_in">document</span>.getElementById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML5表单"><a href="#HTML5表单" class="headerlink" title="HTML5表单"></a>HTML5表单</h2><ol>
<li><p>input的类型(type字段)有所增加, 不是所有的浏览器都支持, 主要包含下列:</p>
<ul>
<li>color, 颜色选取盘</li>
<li>month, 月份选择器</li>
<li>date, 日期选择器</li>
<li>datetime-local, 日期和时间选择器</li>
<li>time, 时间选择器</li>
<li>email, email格式验证</li>
<li>number, 数字框</li>
<li>range, 滑动条</li>
<li>search, 搜索框, 会在右侧显示’x’图标</li>
</ul>
</li>
<li><p>新表单元素:</p>
<ul>
<li>datalist元素, 有自动完成功能, 输入字符会提示相应的结果</li>
</ul>
</li>
</ol>
<h2 id="HTML5区块和段落元素"><a href="#HTML5区块和段落元素" class="headerlink" title="HTML5区块和段落元素"></a>HTML5区块和段落元素</h2><p>一个典型的HTML5网页<code>&lt;body&gt;</code>标签内的结构:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">address</span>&gt;</span>作者介绍<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>部分标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span>小组件<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span>广告组件<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>版权声明<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span>联系方式<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="关于CSS"><a href="#关于CSS" class="headerlink" title="关于CSS"></a>关于CSS</h2><p>我的CSS也就差不多是工地水平, 平时也是直接用第三方库的定位来写网页, 而且很多时候就用绝对定位, 所以我觉得有必要在CSS基础上花一点时间.</p>
<h2 id="CSS层叠与继承"><a href="#CSS层叠与继承" class="headerlink" title="CSS层叠与继承"></a>CSS层叠与继承</h2><ol>
<li><p>CSS叫做层叠样式表(Cascading Style Sheets), 其中”<strong>层叠</strong>“的规则很重要:</p>
<ul>
<li><p>同一元素上的同优先级的规则, 写在后面的会被实际利用</p>
</li>
<li><p>元素选择器越具体, 它的<strong>优先级</strong>越高, 越会被实际利用</p>
<p>有一些CSS属性可以由父元素那里<strong>继承</strong>而来.<br>这是CSS的3个基本概念. </p>
</li>
</ul>
</li>
<li><p>CSS属性中, 有些会默认继承, 如文本相关属性, 有些不会默认继承, 这”很大程度上是由常识决定的”. CSS为控制继承机制提供了3个通用值(说实话我觉得这3个值的区别挺费解的,就简要总结了,不一定完全准确):</p>
<ul>
<li><p>inherit, 一定会继承</p>
</li>
<li><p>initial, 和浏览器默认样式持同(如字体颜色是黑色)</p>
</li>
<li><p>unset, 默认继承的继承, 不继承的不继承</p>
<p>可以使用all属性来重新设置所有属性, 当然all属性的值只能是上面中的一个.</p>
</li>
</ul>
</li>
<li><p>一个选择器的优先级可以说是由四个部分组成:</p>
<ul>
<li><p>千位, 如果是内联样式则得一分(内联样式没有选择器所以总是1000分)</p>
</li>
<li><p>百位, 选择器中包含ID选择器则该位得一分</p>
</li>
<li><p>十位, 选择器中包含类选择器, 属性选择器或者伪类则该位得一分</p>
</li>
<li><p>个位, 选择器中包含元素, 伪元素选择器则该位得一分</p>
<table>
<thead>
<tr>
<th align="center">选择器</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h1</td>
<td align="center">0001</td>
</tr>
<tr>
<td align="center">p::first-letter + .name</td>
<td align="center">0012</td>
</tr>
<tr>
<td align="center">#name &gt; div:hover</td>
<td align="center">0111</td>
</tr>
<tr>
<td align="center">内联样式</td>
<td align="center">1000</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>!important</code>可以用来覆盖优先级计算, 优先使用该CSS规则. 当然, 也可以用更高优先级或更靠后的标有<code>!important</code>的CSS规则来覆盖已有的<code>!important</code>规则. 不建议使用<code>!important</code>, 不过在某些时候, 这一特性很有用. 比如, 用户想让页面内所有元素放大一倍, 那么<code>!important</code>就很有用了.</p>
</li>
</ol>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ol>
<li><p>关于类型, 类和ID选择器, 不再赘述.</p>
</li>
<li><p>属性选择器:</p>
<ul>
<li><code>[attr]</code>, 匹配带有attr属性的元素</li>
<li><code>[attr=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值为”value”</li>
<li><code>[attr~=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值中(由空格隔开)至少有一个为”value”</li>
<li><code>[attr|=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值为”value”, 或以”value-“开头</li>
<li><code>[attr^=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值以”value”开头</li>
<li><code>[attr$=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值以”value”结尾</li>
<li><code>[attr*=&quot;value&quot;]</code>, 匹配带有attr属性的元素, 且attr属性值含有”value”字段</li>
<li><code>[attr=&quot;value&quot; i]</code>, 匹配带有attr属性的元素, 大小写不敏感(HTML默认大小写敏感)</li>
</ul>
</li>
<li><p>伪类选择器是指向已存的元素添加效果, 伪元素选择器是创建新元素并向新元素添加效果, 常用的伪类和伪元素选择器如下:</p>
<ul>
<li>:first-child</li>
<li>:last-child</li>
<li>:only-child, 是指匹配没有兄弟元素的子元素, 即匹配”独生子女”</li>
<li>:hover</li>
<li>:focus</li>
<li>::first-letter</li>
<li>::first-line</li>
</ul>
</li>
<li><p>关系选择器:</p>
<ul>
<li>后代选择器<code> </code></li>
<li>子代选择器<code>&gt;</code>, 仅会匹配直接子代</li>
<li>邻接兄弟选择器<code>+</code>, 选择该元素之后的兄弟元素</li>
<li>兄弟选择器<code>~</code>, 选择该元素的所有兄弟元素</li>
</ul>
</li>
</ol>
<h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><ol>
<li><p><strong>块级盒子</strong>在水平方向上会扩展所有可用空间, 即和父容器等宽; 每个盒子都会换行; width和height属性起作用; padding, margin和border会将其他元素从当前元素推开.</p>
<p> <strong>内联盒子</strong>不会换行; width和height属性不起作用; 垂直方向padding, margin和border会被应用但不会推开其他内联盒子; 水平方向padding, margin和border会被应用也会推开其他内联盒子.</p>
<p> 元素的<code>display</code>属性会改变其外部显示类型.</p>
</li>
<li><p>在<strong>标准盒模型</strong>中, 设置width和height实际上设置的是content. 在<strong>替代盒模型</strong>中, 设置width和height设置的是content+padding+border. 默认情况下浏览器使用标准盒模型, 如果想启用替代盒模型, 需要在相应的元素上加入<code>box-sizing: border-box</code>CSS规则.</p>
</li>
<li><p>按照我的使用经验, 一般情况下一个元素大小和位置由width和height, top和left系列, 以及right和bottom系列中的2个就可以确定, 如果规定了width和padding-left, 那padding-right的值就不会影响布局了.</p>
<p> margin可以设置为负值, 会收缩空间; padding不可以设置为负值.</p>
</li>
<li><p>所谓外边距折叠, 是指两个外边距相接的元素, 它们的外边距会合并成为一个, 即较大的那个外边距.</p>
</li>
<li><p>边框可以按照上下左右设置, 也可以按照不同的样式来设置. 设置的方式有: <code>boder: 1px solid red</code> <code>border-top: dashed red</code> <code>border-style: dotted</code> <code>border-width: 1px</code> <code>border-color: red</code> <code>border-top-color: red</code>.</p>
<p> 设置边框圆角可以使用<code>border-radius: 10px / 10% 20px 10px</code>, 这等同于</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">10px</span> <span class="number">10%</span>;<span class="comment">/*水平半径10px, 垂直半径10%高度*/</span></span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><ol>
<li><p>在不使用flex(弹性盒子), float(浮动), position(定位)以及multicol(多列)等布局时, 默认的布局方式称为正常布局流.</p>
<p> <strong>浮动</strong>是在网页上创建多列布局的工具之一, 通过设置float的值可以使元素想向左或向右浮动:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;<span class="comment">/*right, none(默认)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于不浮动的元素会围绕浮动的元素布局, 所以如果不想使其他元素围绕浮动的元素, 需要在该元素上添加如下CSS规则:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当然, 浮动的元素在正常文档布局流之外, 非浮动元素的外边距不能用于和浮动元素之间来创建空间, 所以最好的解决办法是新建一个元素来消除浮动:</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 通过不同的定位方式进行布局:</p>
<ul>
<li>相对定位<code>position: relative</code>后元素仍会占据在正常文档流中, 但是视觉上的位置会发生偏移, 偏移量是按照它本来的位置来算的. 通过设置<code>top</code> <code>bottom</code> <code>left</code> <code>right</code>属性来设置该元素的相对位置.</li>
<li>绝对定位<code>position: absolute;</code>会逐层寻找position属性不是<code>static</code>的父元素, 并以这个元素作为定位基准. 如果找不到, 也就是说该元素的所有父元素都是静态定位, 那它会以初始块容器(浏览器视口)来定位.</li>
<li>固定定位<code>posiiton: fixed;</code>和绝对定位类似, 但是总是以初始块容器来定位的.</li>
<li>粘性定位<code>position: sticky</code>会首先表现得跟相对定位一样, 直到滚动到某个阈值后会表现得跟固定定位一致. </li>
</ul>
</li>
<li><p><strong>flex</strong>是一种新型按行或按列布局元素的<strong>一维布局方法</strong>, 它可以很方便地解决子元素垂直居中以及占用等量宽度/高度等问题. 要使用flex布局, 需要在父元素(flex容器)上添加如下CSS规则:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> flex元素放置方向的轴叫做主轴, 垂直于主轴方向的轴叫做交叉轴, 可以通过<code>flex-direction</code>项设置主轴方向; 通过<code>flex-wrap</code>项可以设置是否换行. 这两项设置可以合并起来, 用<code>flex-flow</code>取代:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">    <span class="comment">/*等同于*/</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以通过在flex项上添加<code>flex</code>规则来控制其尺寸, 该值有3个参数, 分别代表剩余空间索取量<code>flex-group</code>, 超出空间缩短量<code>flex-shrink</code>和主轴上的长度<code>flex-basis</code>(会覆盖width和height值). 此外, <code>flex</code>还有几个简写值:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*两者意思等同, 表示会缩短来适应容器, 但不会索取剩余空间, 并根据自己的width和height来设置尺寸*/</span></span><br><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: initial;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*两者意思相同, 表示会索取剩余空间, 会缩短来适应容器, 并根据自己的width和height来设置尺寸, 义如其名&quot;自动&quot;*/</span></span><br><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: auto;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*两者意思相同, 表示既不索取, 也不缩短, 完全按照设定的width和height设置尺寸, 成为非弹性元素*/</span></span><br><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: none;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em><a href="https://www.cnblogs.com/moxiaowohuwei/p/8267624.html">关于flex三个值含义可参考这里</a></em></p>
<p> 通过在flex容器上设置<code>align-items</code>属性控制flex项在交叉轴上的位置, 可选值有</p>
<ul>
<li><p>stretch(默认), 交叉轴方向拉伸填满</p>
</li>
<li><p>center, 保持原长度且居中</p>
</li>
<li><p>flex-start/end, 保持原长度且居起始/结束位置</p>
<p>通过在flex容器上设置<code>justify-content</code>属性控制flex项在主轴上的位置, 可选值有</p>
</li>
<li><p>flex-start(默认), 将flex项布局到主轴起始处</p>
</li>
<li><p>flex-end, 将flex项布局到主轴结尾处</p>
</li>
<li><p>center, 将flex项居中布置</p>
</li>
<li><p>space-around, 将flex项沿主轴均匀分布, 且在两端留下一点空间</p>
</li>
<li><p>space-between, 将flex项沿主轴均匀分布, 在两端不留空间</p>
</li>
</ul>
</li>
<li><p>BFC(块级格式化上下文)是块盒子布局发生的区域, 属于正常布局流, 它相当于一个容器, 保证容器内部元素不会在布局上影响外部元素. 触发BFC有以下几种方式:</p>
<ul>
<li><p>body根元素</p>
</li>
<li><p>浮动元素</p>
</li>
<li><p>绝对定位元素和固定定位元素</p>
</li>
<li><p>overflow: auto / hidden / scroll的元素</p>
</li>
<li><p>display: inline-block / flow-root / flex的元素</p>
<p>BFC主要用于以下几种场景:</p>
</li>
<li><p>消除外边距折叠, 同一个BFC内元素会发生外边距折叠, 把这两个元素放在不同的BFC内就不会折叠了</p>
</li>
<li><p>BFC可以包含浮动的元素, 由于浮动的元素脱离了正常布局流, 导致其突出父容器, 触发父容器的BFC就可以使父容器完整包含浮动元素</p>
</li>
<li><p>BFC元素不会围绕浮动元素, 所以有清除浮动的效果</p>
</li>
</ul>
</li>
<li><p>关于水平居中, 垂直居中.</p>
<ul>
<li>父元素是内联元素, 那父元素完全由子元素撑开, 设置父元素的padding或子元素的margin就可以居中了</li>
<li>父元素是块级元素<ul>
<li>子元素是块级元素, 设置了宽度, 可以使用<code>margin: 0 auto;</code>水平居中</li>
<li>子元素是块级元素, 设置了相对宽度或高度, 那就可以设置<code>margin</code>为百分值, 直接水平居中或垂直居中了</li>
<li>子元素是内联元素, 可以在父元素上使用<code>text-align: center;</code>水平居中</li>
</ul>
</li>
<li>父元素是块级元素, 设置了绝对宽度或高度<ul>
<li>子元素是块级元素, 设置了绝对宽度或高度, 可以直接计算并设置<code>margin</code>, 水平居中或垂直居中</li>
</ul>
</li>
<li>除了这些, 还有普适的方法, 特别适合子元素是块级元素且未设置宽度高度的情况<ul>
<li>flex布局(推荐)</li>
<li>使用transform(因为其百分值能代表自身长宽的百分比), 水平方向上<code>margin-left: 50%;</code>或绝对定位<code>left: 50%;</code>, 垂直方向上, 由于正常布局流下百分值按内联方向(参考CSS杂项第4条), 所以只有绝对定位<code>top: 50%</code>的方法. <strong>其实只要使子元素一角居中, 然后用transform位移半个身位即可</strong></li>
<li>绝对定位下, 设置子元素宽高, 以及top, left, bottom, right为0, <code>margin: auto</code>即可居中布置</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><ol>
<li><p>设置背景颜色: <code>background-color: rgba(0, 0, 0, 0.1)</code>.</p>
</li>
<li><p>设置背景图片, 背景图片会覆盖背景颜色:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(...);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="comment">/*或repeat, repeat-x, repeat-y*/</span></span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="comment">/*或cover-保持高宽比且图像足够大可能超出区域, contain-保持高宽比图像完全显示可能有间隙*/</span></span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">10px</span> <span class="number">5px</span>;</span><br><span class="line">    <span class="comment">/*或top center, top 10px left 5px这样的4-value写法*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>渐变:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">105deg</span>, red, <span class="number">10%</span>, black, <span class="number">90%</span>);</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle, red, <span class="number">10%</span>, black, <span class="number">90%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置多个background-image值, 按照顺序, 前者会覆盖后者:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(upper.png), <span class="built_in">url</span>(lower.png), <span class="built_in">radial-gradient</span>(circle, red, <span class="number">10%</span>, green, <span class="number">90%</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat, no-repeat;<span class="comment">/*循环应用, 所以上面的渐变背景应用的&quot;repeat&quot;属性*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用background的简写, 前面的背景会覆盖后面的背景, 背景颜色需要再最后指定, 位置和大小需要以position/size格式指定:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(star.png) no-repeat center center / <span class="number">50px</span> <span class="number">50px</span>,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, red, <span class="number">10%</span>, green, <span class="number">90%</span>),</span><br><span class="line">        purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="CSS杂项"><a href="#CSS杂项" class="headerlink" title="CSS杂项"></a>CSS杂项</h2><ol>
<li><p>CSS溢出</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;<span class="comment">/*visible(默认值), scroll, auto*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 或分别指定两个方向:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 或者这样:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当x和y两个值有一个是visible另一个不是的话, 那visible会被改为auto, 所以下面两个等价:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-x</span>: scroll;</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="attribute">overflow-x</span>: scroll;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS字体主要包括如下一系列设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;<span class="comment">/*italic*/</span></span><br><span class="line">    <span class="attribute">font-weight</span>: normal;<span class="comment">/*bold*/</span></span><br><span class="line">    <span class="attribute">text-transform</span>: none;<span class="comment">/*uppercase, lowercase, capitalize, full-width*/</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: none;<span class="comment">/*underline, overline, line-through*/</span></span><br><span class="line">    <span class="attribute">text-align</span>: left;<span class="comment">/*right, center, justify*/</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>calc</code>函数可以方便地在CSS中进行计算:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">10px</span> + <span class="number">10%</span> + <span class="number">2vw</span>);<span class="comment">/*注意+和-前后要有空格*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用百分值设置内外边距时, 是按照内联尺寸(汉语英语都是左右方向)计算的, 也就是说下面的设置会把所有内边距都设置为其父元素的<strong>宽度</strong>的10%.</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用min-和max-来设置高度和宽度的最小值和最大值.</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>10px</code>是指绝对大小为10像素, <code>1.5em</code>是指1.5倍于父元素字体大小, <code>1.5rem</code>是指1.5倍于根元素字体大小, <code>1vh</code>是指视口高度的1%, <code>1vw</code>是指视口宽度的1%.</p>
</li>
<li><p>使用<code>object-fit</code>设置图片的填充方式, 包含<code>contain</code> <code>cover</code> <code>fill</code>(充满, 可能会改变高宽比).</p>
</li>
<li><p>使用媒介查询来确定屏幕大小:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>), screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">800px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS的<code>transform</code>属性可以用于:</p>
<ul>
<li>绕(0, 0)点旋转<code>transform: rotate(180deg)</code></li>
<li>缩放<code>transform: scale(1.5, 2)</code></li>
<li>位移<code>transform: translate(100px, 50%)</code></li>
<li>倾斜<code>tranform: skew(30deg, 30deg)</code></li>
</ul>
</li>
<li><p>CSS的<code>transition</code>属性可以实现过渡效果, 用法如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ele</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: &lt;proprerty&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><property>用来设置具体的过渡项, 如color, margin等, 可用all来设置全部变动项</li>
<li><timing-function>用来设置缓动函数, 即过渡过程中属性怎么变化, 可取ease, linear等</li>
</ul>
<p>由于CSS的<code>transition</code>需要触发的事件, 不能重复执行, 且不能自定义中间态, 所以它的升级版<code>animation</code>出现.</p>
</li>
</ol>
<h2 id="Sass简单介绍"><a href="#Sass简单介绍" class="headerlink" title="Sass简单介绍"></a>Sass简单介绍</h2><ol>
<li><p>变量.</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$red-border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="variable">$red-border</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套.</p>
<p> &amp;代表父选择器:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用关系选择器和群组选择器:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">    <span class="selector-id">#a</span>, <span class="selector-id">#b</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    &gt; <span class="selector-id">#c</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 属性嵌套:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span> 1px solid red &#123;</span><br><span class="line">        radius: <span class="number">5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入.</p>
<p> 导入a.sass文件和_b.sass文件, 其中_b.sass不会生成独立的css文件, 仅被其他sass文件引用:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>

<p> 为了防止引用文件中的规则对自己写的规则产生影响, 在写引用文件时要加上<code>!default</code>, 表示如果此变量已定义则使用其已定义好的值, 下面的例子中实际的变量值为blue:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_b.sass</span></span><br><span class="line"><span class="variable">$color</span>: red !default;</span><br></pre></td></tr></table></figure>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某个sass文件</span></span><br><span class="line"><span class="variable">$color</span>: blue;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>

<p> 嵌套导入:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_b.scss</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某个sass文件</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>混合器, 用于展示性样式的重用.</p>
<p> 普通用法:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> color-rules &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#content</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="keyword">@include</span> color-rules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 传参:</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> color-rules(<span class="variable">$hover-color</span>) &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="variable">$hover-color</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#content</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="keyword">@include</span> color-rules(blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承, 用于语义化样式的重用.</p>
 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.special-notice</span> &#123;</span><br><span class="line">    <span class="keyword">@extend</span> .notice;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器基础</title>
    <url>/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文包含了浏览器的部分基础内容, 包括浏览器的工作原理, 客户端存储, 以及多线程的相关问题, 不是教程, 不以总结全面为目标, 仅仅是记录下自己觉得有价值的点, 作为参考. 本文包含了很多个人理解, 不一定是正确的, 这是我当前的认知水平.</p>
<a id="more"></a>

<h2 id="浏览器的工作原理概述"><a href="#浏览器的工作原理概述" class="headerlink" title="浏览器的工作原理概述"></a>浏览器的工作原理概述</h2><ol>
<li><p>浏览器的构成.</p>
<p> <img src="./components.png" alt="浏览器的构成"></p>
<p> 浏览器主要由以下几个部分构成:</p>
<ul>
<li>用户界面, 包括地址栏, 前进/后退按钮, 书签菜单等, 即浏览器的”前端”</li>
<li>浏览器引擎, 在用户界面和渲染引擎之间传送指令(说实话我不清楚这一部分的真正角色, 可能各套壳浏览器会修改这一部分吧)</li>
<li><strong>渲染引擎</strong>, 解析HTML和CSS, 并计算页面布局, 确定元素位置</li>
<li>JS解释器, 解释和执行JavaScript代码</li>
<li>网络, 用于网络调用, 比如HTTP请求, 公开了与平台无关的通用接口, 而在底层使用操作系统的网络方法(最终是使用<strong>网卡</strong>)</li>
<li>用户界面后端, 用于绘制基本的窗口小部件, 公开了与平台无关的通用接口, 而在底层使用操作系统的用户界面方法(最终是使用<strong>显卡</strong>)</li>
<li>数据存储, 用于浏览器在硬盘保存数据, 也叫数据持久层(最终是使用<strong>硬盘</strong>)</li>
</ul>
<p> <em>此部分参考了<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a>.</em></p>
</li>
<li><p>浏览器的工作流程. 下面的图片是在<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png">原图片</a>的基础上, 加上我自己的理解, 绘制的浏览器工作流程图, 使用的是WebKit渲染引擎.</p>
<p> <img src="./webkit_flow.png" alt="WebKit渲染引擎浏览器工作流程图"></p>
<p> 在上图中, 我们可以清晰地看到浏览器的工作流程.</p>
<ul>
<li>浏览器的工作当然是先从<code>用户界面(User Interface)</code>开始的. 用户的一些操作, 比如点击链接, 输入url跳往指定地址等会触发指令, 通过<code>浏览器引擎(Browser Engine)</code>传往<code>渲染引擎(Render Engine)</code></li>
<li><code>浏览器引擎(Browser Engine)</code>还会从<code>数据持久层(Data Persistence)</code>中取出储存的数据, 如Cookie, 缓存等, 一并送往<code>渲染引擎(Render Engine)</code></li>
<li>在<code>渲染引擎(Render Engine)</code>中, 由<code>loader</code>负责接收指令, 并且根据指令调用<code>网络(Networking)</code>, 获得相应的文件</li>
<li>获得的文件中, HTML部分交由<code>HTML Parser</code>处理, 形成<code>DOM树(DOM Tree)</code>; 样式表部分交由<code>CSS Parser</code>处理, 形成样式规则; JavaScript部分交由<code>JavaScript解释器(JavaScript Interpreter)</code>处理, 把解析结果应用到DOM树和样式规则上. 最终解析完毕的样式规则会附加到DOM树上</li>
<li>之后渲染引擎的<code>布局(Layout)</code>工作, 把包含样式规则的<code>渲染树(Render Tree)</code>转换成包含坐标信息的渲染树. 在首次布局之后, 再次发生的布局被称为<code>重排(Relayout)</code></li>
<li>之后渲染引擎的<code>绘制(Paint)</code>工作, 调用<code>用户界面后端(UI Backend)</code>将每个节点绘制出来. 在首次绘制之后, 再次发生的绘制被称为<code>重绘(Repaint)</code></li>
</ul>
<p> <em>此部分参考了<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a>.</em></p>
</li>
<li><p>大多数情况下, 我们使用Gecko的术语<code>回流(Reflow)</code>表示重排的过程.</p>
<ul>
<li>渲染树中元素的尺寸, 结构或某些属性发生改变时, 会发生回流. 从上面的流程图可以看到, 回流必然引发重绘</li>
<li>当一些不影响元素在布局流中的位置的属性改变时, 如<code>color</code> <code>visibility</code>, 仅会发生重绘</li>
</ul>
<p>由于频繁的回流和重绘会影响性能, 所以在写代码的时候尽量遵循一定的原则避免频繁的回流和重绘:</p>
<ul>
<li>不使用table布局</li>
<li>避免设置多层样式</li>
<li>避免使用CSS表达式(如<code>calc()</code>)</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上, 否则会引起父元素的频繁回流</li>
<li>避免频繁使用JavaScript操作样式, 应多次一并修改</li>
<li>避免频繁操作DOM, 可创建<code>documentFragment</code>, 在其上面进行DOM操作, 最后附加到DOM树上</li>
</ul>
</li>
<li><p>HTML的解析过程, 是可能会被普通<code>&lt;script&gt;</code>标签的下载和解析阻塞的. 我们知道HTML文件是自上而下解析成DOM的, 当遇到普通<code>&lt;script&gt;</code>标签时, 会暂停HTML解析, 进行相应的JavaScript(下载和)解析, 因为此时JavaScript可能会操作DOM.</p>
<p>CSS不会阻塞HTML解析, 但会阻塞渲染树的生成, 也就是说CSS只有全部解析完毕才会附加到DOM上, 形成渲染树. 然而JavaScript可能会操作样式, 所以浏览器在遇到普通<code>&lt;script&gt;</code>标签之前的CSS时就会暂停HTML解析过程, 也就是说普通<code>&lt;script&gt;</code>标签之前的CSS会阻塞HTML解析, 之后的CSS就不会阻塞HTML解析了. 这其实是因为每个普通<code>&lt;script&gt;</code>解析完之后, 浏览器会渲染一次页面, 所以必须用到之前的CSS.</p>
<p>DOM解析完毕(HTML解析和JavaScript解析的双重结果)时, 触发<code>DOMContentLoaded</code>事件. 当然, 这时的图片啊普通<code>&lt;script&gt;</code>标签之后的CSS啊等资源不一定下载解析完毕, 当所有资源下载解析完毕时, 触发<code>load</code>事件.</p>
<p>异步加载JavaScript的两个方式(可以见我的<a href="https://sien75.github.io/blog/2020/08/12/%E9%83%A8%E5%88%86ES6%E7%9F%A5%E8%AF%86/#Module">部分ES6知识-Module部分</a>)中, defer类会在整个同步代码(HTML和普通<code>&lt;script&gt;</code>标签中的JavaScript)解析完毕之后再解析, 会阻塞<code>DOMContentLoaded</code>事件的触发. 而async类的解析过程会阻塞同步代码解析, 进而阻塞<code>DOMContentLoaded</code>事件的触发, 但是如果在同步代码解析后async类内代码才下载完, 那其就不会阻塞<code>DOMContentLoaded</code>事件的触发了.</p>
</li>
<li><p>下图为浏览器接口示意图(根据我自己的理解画的), 所谓Web API, 就是指使用JavaScript去读(获得)或写(控制)其它单位的方法. 这里的其他单位可能是渲染引擎, 也可能是其他JS线程, 也可能是硬件, 当然最终都是控制的硬件.</p>
<p>每一种访问都有其专门的接口, 在JavaScript里面体现为一种特定的对象类型. 比如你</p>
<ul>
<li>想访问渲染引擎里的DOM, 那就用到了<code>Document</code>类型</li>
<li>想访问Web Worker线程, 那就用到了<code>Worker</code>类型</li>
<li>想在内存里新建一定大小的数据, 那就用到了<code>ArrayBuffer</code>类型</li>
<li>想访问硬盘上的二进制文件, 那就用到了<code>Blob</code>类型</li>
<li>想通过网卡异步访问互联网的内容, 那就用到了<code>XMLHttpRequest</code>类型</li>
</ul>
<p><img src="./interface.png" alt="浏览器接口示意图"></p>
<p>DOM接口和BOM接口是使用EcmaScript进行Web开发的基本Web API, 我们把这两部分和EcmaScript合称JavaScript. 但是由于浏览器的日益复杂, 浏览器本身组成部分和支持的硬件越来越多, 所以仅仅使用DOM和BOM无法满足需求. 在这里我倾向于取JavaScript的狭义, 即JavaScript = EcmaScript.</p>
<p>使用JavaScript(EcmaScript)来操作浏览器以及各种硬件, 需要包括DOM接口和BOM接口在内的各种Web API的扶持, 也就是说, Web API实际上赋予了开发者使用JavaScript(EcmaScript)开发各种功能的Web应用的能力, 是构建于JavaScript(EcmaScript)语言之上的.</p>
</li>
</ol>
<h2 id="客户端存储-–-Storage"><a href="#客户端存储-–-Storage" class="headerlink" title="客户端存储 – *Storage"></a>客户端存储 – *Storage</h2><p>客户端有2个存储数据的对象.</p>
<ul>
<li>localStorage用于长久保存网站数据, 除非手动清除, 不会消失</li>
<li>sessionStorage用于临时保存网站数据, 关闭窗口或标签页时数据就会被删除<br>两个对象使用方法都一样, 以localStorage为例:  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.data = <span class="number">1</span>;<span class="comment">//设置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.data);<span class="comment">//读取(结果为字符串)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">localStorage</span>.data;<span class="comment">//删除</span></span><br><span class="line"><span class="built_in">localStorage</span>.clear();<span class="comment">//全部清除</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="客户端存储-–-IndexedDB"><a href="#客户端存储-–-IndexedDB" class="headerlink" title="客户端存储 – IndexedDB"></a>客户端存储 – IndexedDB</h2><p><em>此部分参考了<a href="https://www.ruanyifeng.com/blog/2018/07/indexeddb.html">https://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></em><br>由于cookie大小不能超过4KB, 且每次请求都会发送给服务器; *Storage也有大小限制, 不提供搜索功能, 不能建立自定义的索引. 所以需要一种新的解决方案. IndexedDB是一种NoSQL, 可以在客户端存储大量数据, 还支持二进制储存.</p>
<ol>
<li><p>基本概念:</p>
<ul>
<li>数据库(IDBDatabase对象), 数据总容器, 可以建立多个</li>
<li>对象仓库(IDBObjectStore对象), 每个数据库中包含若干个对象仓库, 类似于SQL中的表</li>
<li>索引(IDBIndex对象), 类似于SQL中的列名</li>
<li>事务(IDBTransaction对象), 数据的增删改查都要通过它完成</li>
<li>操作请求(IDBRequest对象), 打开或新建数据库时获取到的对象</li>
<li>主键, 即默认的索引, 可以指定为某个属性, 也可以是自动生成的递增数据编号</li>
</ul>
</li>
<li><p>打开, 新建和修改数据库<br> 通过以下方法打开, 新建或修改数据库:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = indexedDB.open(dbName, dbVerion);</span><br></pre></td></tr></table></figure>
<p> 不指定dbVersion, 则使用当前版本. 返回的request是一个<code>IDBRequest对象</code>.</p>
<ul>
<li>如果操作成功则会触发success事件, 此即打开</li>
<li>如果指定的版本高于当前版本, 且操作成功则会触发upgradeneeded事件, 此即修改</li>
<li>如果指定的数据库名字不存在, 且操作成功则会触发upgradeneeded事件, 此即新建</li>
<li>如果操作错误, 则会触发error事件<br>3个事件的使用如下:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;<span class="comment">//这是个`IDBDatabase对象`</span></span><br><span class="line">    db.objectStoreNames;<span class="comment">//获得该数据库下所有的</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//如果要新建数据库的话, 按下面步骤操作</span></span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;</span><br><span class="line">    <span class="keyword">let</span> objStore = db.createObjectStore(<span class="string">&#x27;newOS&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);<span class="comment">//这个是`IDBObjectStore对象`</span></span><br><span class="line">    objStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;);<span class="comment">//这个是`IDBIndex对象`</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.target.error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据库内对象仓库的增删改查<br> 对对象仓库进行增删改查, 需要先获取该<code>IDBObjectStore对象</code>. 在新建对象仓库时可以通过<code>db.createObjectStore</code>返回值获得该对象, 但是不能这样直接使用, 而是要通过事务对象<code>IDBTransaction对象</code>来获得<code>IDBObjectStore对象</code>. 通过如下方法获得事务对象:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tsc = db.transaction([<span class="string">&#x27;objectStorageName&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p> 其中db是上面的<code>IDBDatabase对象</code>, 之后就可以获取到相应的<code>IDBObjectStore对象</code>了:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objStore = tsc.objectStore(<span class="string">&#x27;objectStorageName&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p> 实际的query操作:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = objStore.add(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;);<span class="comment">//增</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.delete(<span class="number">1</span>);<span class="comment">//删, 使用主键值作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.put(&#123;<span class="attr">name</span>: <span class="string">&#x27;amy&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;, <span class="number">1</span>);<span class="comment">//改, 第二个参数是主键值</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.get(<span class="number">1</span>);<span class="comment">//查, 使用主键值作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.index(<span class="string">&#x27;name&#x27;</span>).get(<span class="string">&#x27;sam&#x27;</span>);<span class="comment">//查, 使用索引作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.openCursor();<span class="comment">//遍历, 监听query的success事件</span></span><br><span class="line"><span class="comment">//以上query都有success和error事件, 都是`IDBRequest对象`, 在监听函数内部通过e.target.result或this.result或query.result访问到结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用监听函树实例(遍历):</span></span><br><span class="line">query.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cursor = e.target.reuslt;</span><br><span class="line">    <span class="keyword">if</span>(cursor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(cursor.value, cursor.key);</span><br><span class="line">        cursor.continue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li><p>浏览器的进程和线程</p>
<p><code>进程(process)</code>是操作系统分配资源的最小单位, <code>线程(thread)</code>是程序执行的最小单位; 进程由线程组成, 进程间相互独立, 同一进程的线程之间共享资源; 线程切换比进程快.</p>
<p>Chrome浏览器使用的是多进程隔离不同的标签页, 在每一个进程中, 有着渲染引擎线程, JavaScript主线程, 定时器线程, 事件线程以及网络线程等. 除了各标签页进程外, Chrome还有主进程, 扩展程序进程等.</p>
</li>
<li><p><code>Web Worker</code>和<code>Service Worker</code></p>
<p>JavaScript是设计用来操作DOM的语言, 为了避免复杂性, JavaScript是一种<strong>单线程</strong>语言. 由于JavaScript主线程和渲染引擎线程互斥, 所以如果JavaScript主线程上有一些耗时的代码, 那么必然会阻塞其他代码的执行, 也会阻塞页面的渲染. 所以, 如果我们需要运行一些耗时的代码时, 完全可以开辟一个新的线程, 这就是<code>Web Worker</code>. <code>Web Worker</code>实际上是存在于标签页进程内部的线程.</p>
<p>然而<code>Web Worker</code>是跟随标签页进程的, 当标签页关闭了, 其工作也就结束了. 如果想持久化, 那就需要<code>Service Worker</code>.</p>
<p><code>Service Worker</code>本身也是一个新的线程, 但是它是独立于标签页线程的, 标签页的关闭不会导致其结束. 而且, <code>Service Worker</code>还被赋予中间人代理的权利, 即抓取网络请求并作出修改, 再送给渲染引擎的权利. 借着这两点, 它可以做到对网络请求文件的缓存, 使页面可以离线访问. 它还有消息推送的能力, 使得Web网页变得更像一个本地应用.</p>
</li>
<li><p>事件循环(Event Loop)</p>
<p><em>关于Node.js的事件循环, 见我的关于Node.js的文章<a href="https://sien75.github.io/blog/2020/09/08/Node-js%E5%9F%BA%E7%A1%80/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop">Node.js基础</a></em></p>
<p>在Web中, 有大量的多线程操作, 比如I/O(ajax, 读文件等), UI交互, 定时器, 上面提到的Worker等, 为了不阻塞主线程, 它们最好是<strong>异步</strong>运行, 基于<strong>事件</strong>来通知主线程. 同时, 我们还可以通过Promise来对它们包装(Promise代表执行顺序, 是一种异步包装方式, 本身不会开辟新线程执行代码).</p>
<p>浏览器的异步执行方式是这样的:</p>
<p>JavaScript主线程中JavaScript解释器自上而下解释主任务代码, 根据作用域链对执行栈进行压栈弹栈, 遇到多线程代码会开辟子线程处理. 子线程的代码只要执行完毕, 就会触发事件通知主线程, 并往任务队列里面添加任务. 主线程接到事件通知, 待空闲时就会检测任务队列, 只要其中有任务, 就出队一个任务, 将其压入执行栈执行, 执行完毕后再次在任务队列里取任务, 直到任务队列为空. 这就是<code>事件循环(Event Loop)</code>机制.</p>
<p>如下图所示, 任务分为两种, <code>micro task(微任务)</code>和<code>macro task(宏任务)</code>, 前者主要包含包含<code>Promise</code>, 后者包含主任务, <code>setTimeout</code>, <code>setInterval</code>, I/O, UI交互, postMessage等. JavaScript主线程会先从宏任务队列中出队一个任务来执行(第一次取出的就是主任务), 任务执行完毕后再读取微任务队列, 并按顺序执行所有的微任务, 只有微任务队列没有事件时, 才会再次读取宏任务队列. 这样的话, 如果某些前面的任务执行特别耗时间的话, <code>setTimeout</code>和<code>setInterval</code>这些函数的定时可能是不准确的.</p>
<p><img src="./event_loop.png" alt="浏览器中的事件循环"></p>
<p>关于<code>requestAnimationFrame</code>, 它是异步执行(基于事件)的, 但它既不是微任务, 也不是宏任务. 可以认为还存在一个<code>requestAnimationFrame</code>任务队列, 在每次事件循环的渲染步骤前(参考上图), 会检测是否有<code>requestAnimationFrame</code>任务, 并全部执行.</p>
<blockquote>
<p>在现代Chrome浏览器里面, <code>setTimeout</code>和<code>setInterval</code>的时间最小设置值是1(ms), 也就是说第二个参数设为1和0是一样的.</p>
</blockquote>
<blockquote>
<p>由于一方面不好确认浏览器的最佳刷新间隔, 另一方面<code>setTimeout</code>和<code>setInterval</code>受到事件循环中延时的影响更大, 所以自定义动画推荐使用<code>requestAnimationFrame</code>.</p>
</blockquote>
<p>下面是关于浏览器事件循环的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)&#125;, <span class="number">0</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> promise;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">依次显示</span></span><br><span class="line"><span class="comment">Promise</span></span><br><span class="line"><span class="comment">Hi!</span></span><br><span class="line"><span class="comment">resolved</span></span><br><span class="line"><span class="comment">setTimeout0</span></span><br><span class="line"><span class="comment">setTimeout1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p><em>此部分参考了<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a></em></p>
<ol>
<li><p>基本用法.</p>
<p>主线程(JavaScript解释器线程):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span><br><span class="line">worker.postMessage(&#123;<span class="attr">content</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;main thread recieved message!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">worker.onerror = <span class="built_in">console</span>.error;</span><br></pre></td></tr></table></figure>
<p>Worker线程全局环境绑定了监听函数和消息发送函数, work.js的内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;web worker recieved message!&#x27;</span>);</span><br><span class="line">    postMessage(&#123;<span class="attr">content</span>: <span class="string">&#x27;Hello too&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭Worker线程:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.terminate();<span class="comment">//主线程内</span></span><br><span class="line">close();<span class="comment">//Worker线程内</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据通信.</p>
<p>主线程和Worker线程之间的通信是拷贝的关系, 即先把通信内容串行化(转换成字符串), 接收方再将其还原. 主线程和Worker线程之间也可以交换二进制数据, 但是如果二进制数据太大, 这样的拷贝既浪费时间, 又浪费存储资源. 在此, 可以通过直接将二进制数据转移给Worker线程.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line">worker.postMessage(</span><br><span class="line">    &#123;ab1, ab2&#125;,</span><br><span class="line">    [ab1, ab2]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中第一个参数就是指传递的变量, 第二个参数是一个数组, 包含了需要转移的二进制数据变量名.</p>
</li>
<li><p>同文件的Web Worker.   </p>
<p>使用Web Worker可以不用单独的文件, 借助Blob类型的URL构造能力, 可以在单个文件内创建Web Worker.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let work &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F;web worker codes</span><br><span class="line">&#125;</span><br><span class="line">let blob &#x3D; new Blob(&#96;($&#123;work.toString()&#125;)()&#96;);</span><br><span class="line">let url &#x3D; URL.createObjectURL(blob);</span><br><span class="line">let worker &#x3D; new Worker(url);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">let work &#x3D; &#96;</span><br><span class="line">    &#x2F;&#x2F;web worker codes</span><br><span class="line">&#96;;</span><br><span class="line">let blob &#x3D; new Blob(work);</span><br><span class="line">let url &#x3D; URL.createObjectURL(blob);</span><br><span class="line">let worker &#x3D; new Worker(url);   </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>建议参考<a href="https://lavas-project.github.io/pwa-book/chapter04.html">https://lavas-project.github.io/pwa-book/chapter04.html</a>, 文章把Service Worker作为PWA技术的一部分, 讲解得非常详实. 由于Service Worker并不是一种基础知识, 在此我就不总结了.</p>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js基础</title>
    <url>/blog/2020/09/08/Node-js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文包含了Node.js的部分基础内容, 参考了<a href="http://nodejs.cn/learn">http://nodejs.cn/learn</a>, 请注意本文不是教程, 不以总结全面为目标, 仅仅是记录下自己觉得有价值的点, 作为参考.</p>
<a id="more"></a>

<h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h2><p><em>关于浏览器的事件循环, 见我的关于浏览器的文章<a href="https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B">浏览器基础</a>.</em></p>
<p>首先我们要表述一下Node.js的事件循环, 在我基本弄清浏览器的事件循环之后, Node.js的事件循环对我的认知冲击了好多次, 我也不知道为啥要设计得这么复杂这么拗[摊手]… 说实话Node.js的事件循环有很多的坑, 主要有以下几个方面:</p>
<ul>
<li>加入了<code>process.nextTick</code>, 你可以认为它是微任务, 但它总在其他微任务之前(说好的队列先进先出, 但它有”军人优先”的权利)</li>
<li>加入了<code>setImmediate</code>, 但是并不一定是”立刻”执行, 并不如<code>process.nextTick</code>快</li>
<li>之前是每执行完一个阶段的所有宏任务才会去执行微任务, 但是新版本Node.js向浏览器看齐了, 即每单个宏任务后都会清空微任务队列(很多旧教程都是错的啊)</li>
<li>如果主线程在执行定时器任务, 那么此时产生的任务会被加入到下一个循环中, 在执行Immediate任务时也是这样(文档里也没提啊)</li>
</ul>
<p>在Node.js中, 有大量的多线程操作, 比如I/O(ajax, 读文件等), 定时器等, 为了不阻塞主线程, 它们最好是<strong>异步</strong>运行, 基于<strong>事件</strong>来通知主线程. 同时, 我们还可以通过Promise来对它们包装(Promise代表执行顺序, 是一种异步包装方式, 本身不会开辟新线程执行代码).</p>
<p>此外, Node.js还规定了<code>process.nextTick</code>和<code>setImmediate</code>这两个函数, 用于在异步操作的不同时机触发事件, 产生任务.</p>
<p>Node.js的异步执行方式和之前好像有出入, 以下结论基于Node.js(v14.5.0)的结果.</p>
<p>Node.js的异步执行方式是这样的:</p>
<p>JavaScript主线程中JavaScript解释器自上而下解释主任务代码, 根据作用域链对执行栈进行压栈弹栈, 遇到多线程代码会开辟子线程处理. 子线程的代码只要执行完毕, 就会触发事件通知主线程, 并往任务队列里面添加任务. 主线程接到事件通知, 待空闲时就会检测任务队列, 只要其中有任务, 就出队一个任务, 将其压入执行栈执行, 执行完毕后再次在任务队列里取任务, 直到任务队列为空. 这就是<code>事件循环(Event Loop)</code>机制.</p>
<p>如下图所示, 任务分为两种, <code>micro task(微任务)</code>和<code>macro task(宏任务)</code>, 前者主要包含<code>process.nextTick</code>, <code>Promise</code>, 后者包含主任务, <code>setTimeout</code>, <code>setInterval</code>, I/O, <code>setImmediate</code>等. JavaScript主线程会先从<strong>宏任务队列循环</strong>中出队一个宏任务(第一次取出的就是主任务), 执行这个宏任务, 任务执行完毕后再读取微任务队列, 并按顺序执行所有的微任务, 只有微任务队列没有事件时, 才会再次读取宏任务队列循环. 读取宏任务先读取本宏任务队列, 只有本宏任务队列没有任务时, 才会按照循环读下一个宏任务队列.</p>
<p><img src="./event_loop.png" alt="Node.js中的事件循环"></p>
<p>和浏览器不同的是, 首先我们可以认为Node.js的事件循环的微任务队列中<code>process.nextTick</code>总是在最前面的, 再者Node.js的宏任务队列有多个, 每次读宏任务都要清空本宏任务队列, 才会去读下一个宏任务队列.</p>
<p>另外, Node.js和浏览器的退出机制不同, 这对事件循环有一定的影响. 和浏览器一样的是, Node.js也是只要有事件就会启动事件循环, 清空了队列就会停止事件循环. 不过, 浏览器中不用考虑退出机制, 因为用户自己会退出, 整个页面打开的过程主线程是一直在监听事件的; Node.js不一定会有用户触发的事件, 事情做完了自己会退出, 事件循环也就停止了. Node.js主线程会记录是否还有进行中的子线程(定时器, I/O等), 有的话就会阻塞在poll阶段等待事件, 没有的话就会退出.</p>
<blockquote>
<p>在Node.js中, <code>setTimeout</code>和<code>setInterval</code>的时间最小设置值是1(ms), 也就是说第二个参数设为1和0是一样的. 不过有时把第二个参数设为2也会表现为和1一样(玄学), 所以使用定时器函数时最好把时间间隔设为大于4ms.</p>
</blockquote>
<p>注意, 在执行定时器任务时, 新的任务会被添加到下一个循环. 对于Immediate任务来说也是如此. 这一点可以在下面的例子中看出(‘setTimeout2’).</p>
<p>下面是关于Node.js事件循环的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>);</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">            _();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">        setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">依次显示:</span></span><br><span class="line"><span class="comment">Hi!</span></span><br><span class="line"><span class="comment">setTimeout0</span></span><br><span class="line"><span class="comment">Promise</span></span><br><span class="line"><span class="comment">resolved</span></span><br><span class="line"><span class="comment">setTimeout1</span></span><br><span class="line"><span class="comment">nextTick</span></span><br><span class="line"><span class="comment">setImmediate</span></span><br><span class="line"><span class="comment">setTimeout2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="process对象"><a href="#process对象" class="headerlink" title="process对象"></a>process对象</h2><ol>
<li><p>退出进程</p>
<p>可以使用<code>process.exit(n)</code>来强制退出进程, 其中<code>n</code>代表退出码. 退出码表示进程退出时返回的一个数字, 用于和其他进程通信. 设置退出码还可以通过<code>process.exitCode = 1</code>来设置, 这样不仅<code>process.exit()</code>时会使用该退出码, 进程自然结束时也会使用该退出码. 当然, 不同的退出码有不同的意义, 不同的情况会自动触发不同的退出码, 比如<code>1</code>代表”未捕获异常”. 所以一般不通过编程操作退出码.</p>
</li>
<li><p>向进程发送信号</p>
<p>使用<code>process.kill(pid, signal)</code>来向进程发送信号. pid为进程id, 使用<code>process.pid</code>获得本进程PID; signal为信号, 为字符串或数字, 如<code>SIGTERM</code>或<code>15</code>表示正常终止(非Windows), <code>SIGKILL</code>或<code>9</code>表示立即终止. </p>
<p>有些信号可以绑定事件监听器, 通过`process.on(signal, handle)就可以设置回调函数.</p>
<p>通过<code>process.kill(pid, signal)</code>关闭进程, 那么进程的退出码将会是128加上信号的值.</p>
</li>
<li><p>使用<code>process.nextTick</code>进行异步操作, 详见<a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop">事件循环</a>.</p>
</li>
<li><p>使用<code>process.env</code>读取系统环境变量.</p>
</li>
<li><p>使用<code>process.argv</code>访问命令行参数.</p>
</li>
</ol>
<h2 id="通过命令行I-O"><a href="#通过命令行I-O" class="headerlink" title="通过命令行I/O"></a>通过命令行I/O</h2><ol>
<li><p>使用<code>console</code>对象输出.(和浏览器基本相同)</p>
<ul>
<li><code>console.log()</code></li>
<li><code>console.clear()</code>, 但是Node.js中没有浏览器中的clear()函数</li>
<li><code>console.count()</code>, 打印字符串并计数</li>
<li><code>console.trace()</code>, 打印堆栈踪迹</li>
<li><code>console.time(tag)</code> <code>console.timeEnd(tag)</code>, 计算两者间时间并输出到控制台</li>
<li><code>console.error()</code>, 打印到错误流, 不会再控制台上显示</li>
<li>使用<code>chalk</code>软件包对控制台输出着色(npm安装)</li>
</ul>
</li>
<li><p>从命令行接收输入.</p>
<ul>
<li>使用<code>readline</code>模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>).createInterface(&#123;</span><br><span class="line">    input: process.stdin,</span><br><span class="line">    output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line">readline.question(<span class="string">&#x27;你叫什么名字?&#x27;</span>, <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好 <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">    readline.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Inquirer</code>软件包(npm安装)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> questions = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        message: <span class="string">&#x27;你叫什么名字?&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">inquirer.prompt(questions).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好 <span class="subst">$&#123;answers[<span class="string">&#x27;name&#x27;</span>]&#125;</span>!`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><ol>
<li><p>安装软件包</p>
<ul>
<li><code>npm i package</code> <code>npm i package -S</code> <code>npm i package --save</code>, 安装软件包到当前项目</li>
<li><code>npm i package -D</code> <code>npm i package --sav-dev</code>, 安装仅开发依赖的软件包到当前项目</li>
<li><code>npm i package -g</code>, 全局安装软件包, 一般会添加可执行文件</li>
<li><code>npm i package@n.n.n</code>, 指定版本安装软件包</li>
</ul>
</li>
<li><p>查看软件包</p>
<ul>
<li><code>npm list</code>, 列出当前项目的依赖包</li>
<li><code>npm list --depth=0</code>, 仅列出顶层依赖包, 即写在<code>package.json</code>里的依赖包</li>
<li><code>npm list -g</code>, 列出全局安装的软件包</li>
</ul>
</li>
<li><p>运行可执行文件</p>
<ul>
<li><code>npx exe_name</code>, 运行可执行文件, 依次搜索本项目安装的依赖包, $PATH和网络是否有此可执行文件</li>
<li><code>exe_name</code>, 安装在全局的软件包的可执行文件可直接运行($PATH包含的话)</li>
</ul>
</li>
<li><p>更新软件包</p>
<ul>
<li><code>npm view package version</code>, 查看指定软件包的最新版本</li>
<li><code>npm outdated</code>, 查看当前项目的所有软件包的最新版本</li>
<li><code>npm update</code>, 更新次版本或补丁版本变动的软件包, 不会更新主版本变动的软件包</li>
</ul>
</li>
<li><p>卸载软件包</p>
<ul>
<li><code>npm uninstall package</code>, 卸载软件包, 但不会修改<code>package.json</code></li>
<li><code>npm uninstall package -S</code>, 卸载软件包, 同时删除<code>package.json</code>的<code>dependencies</code>中此软件包的字段</li>
<li><code>npm uninstall package -D</code>, 卸载软件包, 同时删除<code>package.json</code>的<code>devDependencies</code>中此软件包的字段</li>
</ul>
</li>
<li><p><code>package.json</code>中的语义版本控制</p>
<ul>
<li><code>&gt;</code>, 高于指定版本的任何版本</li>
<li><code>&gt;=</code>, 等于或高于指定版本的任何版本</li>
<li><code>&lt;</code>, 低于指定版本的任何版本</li>
<li><code>&lt;=</code>, 低于或高于指定版本的任何版本</li>
<li><code>=</code> <code>[无前缀]</code>, 确切的版本</li>
<li><code>^</code>, 补丁版本和次版本高于指定版本的任何版本</li>
<li><code>~</code>, 补丁版本高于指定版本的任何版本</li>
<li><code>n.n.n - n.n.n</code>, 版本范围</li>
<li><code>||</code>, 组合规则</li>
<li><code>latest</code>, 最新版本</li>
</ul>
</li>
</ol>
<h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p><em>我的疑问: EventEmitter是怎么和Event Loop结合的呢? eventEmitter.emit()这个函数是在什么地方被调用的呢?</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">eventEmitter.on(<span class="string">&#x27;event&#x27;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;event&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _ = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;;</span><br><span class="line">_(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>EventEmitter只是改变了”回调地狱”的书写方式, 本身还是同步运行的.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他的关于fs, http, stream, buffer就不多介绍了, 都是看一看就会的.</p>
<p>不过有一点要提一下. ArrayBuffer是es6里面规定的, 代表储存二进制数据的一段内存.</p>
<p>而TypedArray也是es6里面规定的, 是以指定格式解读ArrayBuffer的一种方法, Uinit8Array是TypedArray(视图)的一种.</p>
<p>Node.js中的Buffer类就是继承自Uint8Array. Buffer类的对象内部实际存在一个ArrayBuffer类的对象, 所以可以认为Buffer是ES6标准中的ArrayBuffer和Uinit8Array的结合体.</p>
<p>请看下面ArrayBuffer和Buffer互转的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把ArrayBuffer转换成Buffer(1)</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(ab.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ab.length; i++) buf[i] = view[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Buffer转换成ArrayBuffer(1)</span></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(buf.length);</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buf.length; i++) view[i] = buf[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ArrayBuffer转换成Buffer(2)</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(ab);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Buffer转换成ArrayBuffer(2)</span></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> ab = buf.buffer;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化概述</title>
    <url>/blog/2020/09/13/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>由于前端项目变得越来越复杂, 如何保证前端项目的多人协同的开发质量和开发效率, 成为越来越重要的问题. 将软件工程引入前端项目, 使前端工程化, 是解决问题的最好办法.</p>
<a id="more"></a>

<h2 id="前端工程化概述"><a href="#前端工程化概述" class="headerlink" title="前端工程化概述"></a>前端工程化概述</h2><p><em>此部分参考了<a href="https://www.zhihu.com/question/24558375">https://www.zhihu.com/question/24558375</a></em></p>
<p>前端工程化应该从模块化, 组件化, 规范化和自动化四个方面来考虑.</p>
<ol>
<li><p>模块化</p>
<p>模块化就是指在文件层面上对复杂的项目进行分割, 并将其合理组装起来的思想. 这是进行多人协作和功能划分的基本保证.</p>
<ul>
<li>JavaScript的模块化. 在之前出现过AMD, CMD, 以及CommonJS等模块加载方案, 不过现在ES6已经在语言层面对模块系统进行了规定, 详见我的<a href="https://sien75.github.io/blog/2020/08/12/%E9%83%A8%E5%88%86ES6%E7%9F%A5%E8%AF%86/#Module">部分ES6知识-Module</a></li>
<li>CSS的模块化, 某个CSS文件引入其他的CSS文件可以使用Sass的<code>@import</code>, 而为了解决CSS的全局选择器的冲突, 可以采用CSS Modules</li>
</ul>
<p>目前的构建工具中, Webpack最为流行. Webpack不仅允许使用ES6的module方法引入JavaScript文件, 还可以通过各种Loader, 同样使用ES6的module方法引入TypeScript, CSS, Sass和静态资源.</p>
</li>
<li><p>组件化</p>
<p>组件化是在UI层面上对各部分进行拆分, 然后按需组合的思想. 组件之间也有继承, 包含等关系. 现在一般通过使用框架来进行组件化, 如Vue.</p>
</li>
<li><p>规范化</p>
<p>所谓规范化, 就是确定开发的标准, 包括目录结构的规定, 接口规范, git规范和UI视觉规范等.</p>
</li>
<li><p>自动化</p>
<p>自动化就是把简单重复的工作交给机器, 使人着眼于真正的问题, 而不是繁琐的步骤. 像Webpack就是一个自动化构建工具, 开发项目时无需关心如何使代码在浏览器上运行, 这个工作由Webpack完成了.</p>
</li>
</ol>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack是一个自动化构建工具. 开发者使用了一套便于大型项目开发的体系, 但是这种体系是浏览器无法理解的, 这里面比如ES6, TypeScript, Sass, vue等, 这些浏览器无法理解的开发技术是为了更好地开发大型前端项目. Webpack就是担任这样一个角色: 把多个开发文件打包成浏览器可以理解的几个HTML, CSS, JavaScript和图片文件. 此外, Webpack还会自动地监听本地代码变化并重新构建, 并且做一些文件优化, 代码校验等.</p>
<p>这里附加一个使用Vue的项目的简单配置, 参考了<a href="https://webpack.wuhaolin.cn/">https://webpack.wuhaolin.cn/</a>:</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;^2.4.2&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;css-loader&quot;: &quot;^0.28.5&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.0.4&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.4.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/blog/2020/09/15/Vue%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文包括了一些”面向面试”的Vue的基础知识, 不成体系, 不是教程, 包括一些零散的问题. 我只记录了我不是很清楚的一些问题, 或者我觉得有价值的问题.</p>
<a id="more"></a>

<h2 id="Vue的实现"><a href="#Vue的实现" class="headerlink" title="Vue的实现"></a>Vue的实现</h2><p>我首先花了几天时间, 参考<a href="https://juejin.im/post/6844903605414133773#heading-12">https://juejin.im/post/6844903605414133773#heading-12</a>的思路, 自己造了一个简单的Vue, 实现了Vue的很基本的几个功能:</p>
<ul>
<li><code>v-bind:attr=&quot;value&quot;</code>的单向属性绑定</li>
<li><code>:attr=&quot;value&quot;</code>的单向属性绑定, 就是上一个的简写</li>
<li><code>v-on:event=&quot;handler&quot;</code>的单向监听函数绑定</li>
<li><code>@event=&quot;handler&quot;</code>的单向监听函数绑定, 就是上一个的简写</li>
<li><code>v-model=&quot;value&quot;</code>双向属性绑定</li>
<li><code>&#123;&#123;variable&#125;&#125;</code>的单向模板传值<br>项目地址: <a href="https://github.com/sien75/ToyVue">https://github.com/sien75/ToyVue</a><br>代码解析: &lt;&gt;</li>
</ul>
<h2 id="Vue不能检测的变动"><a href="#Vue不能检测的变动" class="headerlink" title="Vue不能检测的变动"></a>Vue不能检测的变动</h2><ol>
<li><p>增加对象的属性, 包括:</p>
<ul>
<li>obj.newProperty = value</li>
<li>arr[arr.length] = value</li>
<li>vm.newProperty = value</li>
<li>Object.assign(obj, anotherObj)<br>这些都是向现存的对象中增加属性, 由于Vue会在初始化时对已存属性设置setter, 新增加的属性是无法检测到的.</li>
</ul>
</li>
<li><p>通过索引值设置数组内某一项的值:</p>
<ul>
<li>arr[i] = value<br>不清楚为什么, Vue并没有对数组内的基本数据类型使用<code>Object.defineProperty</code>做setter和getter特性设置, 而是改造了<code>Array.prototype</code>上的<code>push</code> <code>pop</code> <code>unshift</code> <code>shift</code> <code>splice</code>函数, 所以使用上述函数是可以监听到变动的.</li>
</ul>
</li>
<li><p>Vue无法监听变动的统一解决方法:</p>
<ul>
<li>Vue.set(obj, name, value)</li>
<li>vm.$set(obj, name, value)</li>
</ul>
</li>
</ol>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><ol>
<li><p>初始化时的事件:</p>
<ul>
<li><code>beforeCreate</code>, 实例已创建, 数据未绑定</li>
<li><code>created</code>, 数据已绑定, 虚拟DOM未渲染</li>
<li><code>beforeMount</code>, 虚拟DOM已渲染, 未挂载到DOM上</li>
<li><code>mounted</code>, 虚拟DOM已挂载到DOM上, 初始化完毕</li>
</ul>
<p>运行时的事件:</p>
<ul>
<li><code>beforeUpdate</code>, 数据已更新, DOM未更新</li>
<li><code>updated</code>, DOM也已更新</li>
</ul>
<p>销毁时的事件:</p>
<ul>
<li><code>beforeDestroy</code>, 销毁前</li>
<li><code>destroyed</code>, 销毁后</li>
</ul>
</li>
<li><p>初始化时, 父组件和子组件的加载顺序如下:</p>
<ul>
<li>父组件实例化</li>
<li>-1- 父<code>beforeCreate</code></li>
<li>父组件数据绑定</li>
<li>-2- 父<code>created</code></li>
<li>父组件虚拟DOM渲染</li>
<li>-3- 父<code>beforeMount</code></li>
<li>子组件实例化</li>
<li>-4- 子<code>beforeCreate</code></li>
<li>子组件数据绑定</li>
<li>-5- 子<code>created</code></li>
<li>子组件虚拟DOM渲染</li>
<li>-6- 子<code>beforeMount</code></li>
<li>子组件虚拟DOM挂载到父组件虚拟DOM上</li>
<li>-7- 子<code>mounted</code></li>
<li>父组件虚拟DOM挂载到DOM上</li>
<li>-8- 父<code>mounted</code></li>
</ul>
</li>
<li><p>父组件访问子组件钩子函数的方法:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">hook:created</span>=<span class="string">&quot;function&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="组件的data属性为什么是一个函数"><a href="#组件的data属性为什么是一个函数" class="headerlink" title="组件的data属性为什么是一个函数"></a>组件的data属性为什么是一个函数</h2><p>Vue实例的<code>data</code> <code>methods</code> <code>computed</code>都是在实例<code>vm</code>上的, 不同的实例调用的是一个类(构造函数模式), 但是数据不共享.</p>
<p>和Vue实例不同, 组件需要复用, 所以组件的<code>data</code> <code>methods</code> <code>computed</code>都是在<code>Component.prototype</code>上的(原型模式).</p>
<p>对于<code>methods</code> <code>computed</code>来说, 他们本来就是函数, 为了复用, 放在原型上是最佳选择. 而<code>data</code>本来是一个对象, 由于多个相同组件的<code>data</code>不大可能一样, 所以<code>data</code>需要放在组件实例<code>component</code>上.</p>
<p>像Vue这种设置<code>data</code>为函数, <code>data</code>函数里面<code>this</code>会指代实例<code>component</code>本身, 所以多个组件的数据就会被放在各自的实例上, 从而隔离.</p>
<p>当然其实Vue也可以在实现的时候就可以把像<code>data</code>这种每个组件都不同的属性特殊对待, 在初始化时就放到实例上, 这样就不用把<code>data</code>设为函数了.</p>
<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><ol>
<li><p>父组件和子组件之间的<code>props</code>和<code>$emit</code>, 不用多说.</p>
</li>
<li><p>可跨组件的<code>$attrs</code>和<code>$listeners</code>.</p>
<p><code>$attrs</code>指从父组件中获取的所有数据, 但是要去除已在<code>props</code>字段接收到的, 也要去除<code>class</code>和<code>style</code>.</p>
<p><code>$listeners</code>指从父组件中获得的所有监听函数</p>
<p>所以在一个A - B - C三组件继承体系中, B组件中就可以这么写:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">C</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">C</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有组件之间都可以通信的<code>EventBus</code>.</p>
<p>其实原理很简单. 首先要明确一件事, 在Vue实例上<code>this.$emit()</code>发出的事件, 要怎么接收呢? Vue实例没有父组件, 该事件也没有绑定到某一个元素节点上, 要接受需要使用<code>this.$on()</code>监听.</p>
<p><code>EventBus</code>就是把Vue实例放到<code>Vue.prototype</code>上, 由于Vue组件类继承自Vue类, 所以所有组件都可以访问到Vue实例, 那么都可以使用这一事件收发平台了. 例子如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化Vue类时</span></span><br><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任意组件发送事件</span></span><br><span class="line"><span class="built_in">this</span>.$EventBus.$emit(<span class="string">&#x27;event&#x27;</span>, value);</span><br><span class="line"><span class="comment">//任意组件接收事件</span></span><br><span class="line"><span class="built_in">this</span>.$EventBus.$on(<span class="string">&#x27;event&#x27;</span>, <span class="function"><span class="params">v</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$parent</code>, <code>$children</code>和<code>$root</code>.</p>
<p>这个很简单, <code>$parent</code>访问到的就是父组件, <code>$children</code>访问到的就是所有子组件, <code>$root</code>访问到的就是根实例.</p>
</li>
<li><p>使用ref.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&gt;html部分&lt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js部分</span></span><br><span class="line"><span class="built_in">this</span>.$refs.div;<span class="comment">//div元素节点</span></span><br><span class="line"><span class="built_in">this</span>.$refs.child;<span class="comment">//子组件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Vuex方法, 适合大型项目. 关于Vuex, 详见下一部分.</p>
</li>
</ol>
<h2 id="Vue状态管理-–-Vuex"><a href="#Vue状态管理-–-Vuex" class="headerlink" title="Vue状态管理 – Vuex"></a>Vue状态管理 – Vuex</h2><ol>
<li><p>如何引入.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;...&#125;);</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>State – 状态对象.</p>
<p>在Vue实例中访问state是通过computed来实现的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义时</span></span><br><span class="line"><span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//访问时</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用mapState函数简化</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更复杂的mapState用法</span></span><br><span class="line">computed: mapState(&#123;</span><br><span class="line">    count0: <span class="function"><span class="params">state</span> =&gt;</span> state.count + <span class="number">1</span>,</span><br><span class="line">    count1: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">    countPlusLocal(state) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;<span class="comment">//函数运行时绑定到Vue实例上, 所以this指Vue实例(不能用箭头函数)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Getters – 派生状态.</p>
<p>Getters类似于computed. 通过属性访问:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义时</span></span><br><span class="line"><span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        a: <span class="function"><span class="params">state</span> =&gt;</span> state.count + <span class="number">1</span>,</span><br><span class="line">        b: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> state.count + getters.a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//访问时</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    b() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用mapGetters函数简化</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mutations – 变更状态.</p>
<p>通过提交事件来执行mutations函数, 进而变更状态:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义时</span></span><br><span class="line"><span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state, &#123;amount&#125;) &#123;</span><br><span class="line">            state.count += amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//访问时</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>, &#123;<span class="attr">amount</span>: <span class="number">10</span>&#125;);</span><br><span class="line"><span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">    type: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">    amount: <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Actions – 可异步提交Mutations.</p>
<p>为了便于调试, Mutations里的函数都应该是同步函数. 如果需要用到异步函数, 需要actions:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义时</span></span><br><span class="line"><span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        incrementAsync(&#123;commit&#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">reslove</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    commit(<span class="string">&#x27;increment&#x27;</span>, &#123;<span class="attr">ammount</span>: <span class="number">10</span>&#125;);</span><br><span class="line">                    reslove();</span><br><span class="line">                &#125;, <span class="number">100</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//访问时</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;incrementAsync&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>Vue SSR即Vue服务端渲染, 是指在服务器上将Vue模板渲染为HTML字符串, 再将它们发送到浏览器. 所以它会提高浏览器中内容加载速度, 同时也给了服务器更多的负载.</p>
</li>
<li><p>Vue Router有3种:</p>
<ul>
<li>hash模式, 利用的是location.hash</li>
<li>history模式, 利用history.pushState的无刷新更改地址栏</li>
<li>abstract模式, Node.js没有Web API, 只能用这种方式</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Web前端基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>开发完善的跨平台应用</title>
    <url>/blog/2020/11/30/%E5%BC%80%E5%8F%91%E5%AE%8C%E5%96%84%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>本文是我对跨平台开发的一些原理上的探究. 跨平台开发, 是一直以来许多开发者的目标, 一套代码直接运行在不同的平台是一件多么方便的事情! 当然我水平有限, 理解还是比较粗浅, 一定有错误的地方, 在阅读时一方面要谨慎, 避免被误导, 另一方面发现错误的话还请批评指正, 非常感谢!</p>
<a id="more"></a>

<h2 id="计算机之间有硬件和操作系统的不同"><a href="#计算机之间有硬件和操作系统的不同" class="headerlink" title="计算机之间有硬件和操作系统的不同"></a>计算机之间有硬件和操作系统的不同</h2><p>就硬件而言, 主要差异就是cpu的差异. 现如今(2020年)cpu主要有amd64和arm架构, 一种是复杂指令集, 一种是精简指令集. amd64架构的cpu功耗大, 性能强, 主要用于电脑端, 搭载Windows和MacOS/Linux/BSD操作系统. arm架构的cpu功耗相对较小, 性能也相对较弱, 主要用于手机, 搭载Android/iOS操作系统. 此外, arm架构的产品越来越多, 比如树莓派是可以搭载Windows的(当然树莓派本来是搭载Linux的); Apple最近也开发了基于arm架构cpu的M1芯片, 在其上也搭载了MacOS. Linux一众发行版也有很多arm版本操作系统. 可以说, 在当前的时间点, arm架构上可以搭载所有主流操作系统. </p>
<p>就操作系统而言, 现如今(2020年)主要分为两大类, 即Windows和Unix&amp;Unix-like, 后者包含MacOS/iOS/Android/Linux/BSD等. 由于有一些电脑越做越小, 反之平板越做越大, 很多电脑也配备了触摸屏, 反之很多办公事宜都可以在手机上处理, –其实电脑端操作系统和移动端操作系统之间的鸿沟在减小, 它们在互相学习. 然而现如今, 电脑和移动端操作系统还是有明显差异的, 电脑端更适合办公, 以及使用专业性较强和需要高性能的软件, 移动端更适合即时通讯, 资讯类阅读, 简单事件处理等软件. 所以跨平台一般来说分为两种, 一种是跨Windows/MacOS/Linux/BSD, 一种是跨Android/iOS, 当然也有两者兼备且特别成功的, 比如–浏览器. </p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>其实我认为现如今最成功的跨平台技术当属浏览器, 一套代码就可以在不同的平台运行, 而不同操作系统之间的差异全部被掩盖在浏览器庞大又复杂的代码之下. 浏览器的原理我之前小小分析过, 见<a href=""></a>, 主要是渲染引擎和JS解释器这两个核心部件, 通过浏览器的其他”接口类”模块(比如网络模块, 用户界面后端模块等), 再通过操作系统, 接收或调用不同硬件的过程. 我们写前端代码(原生HTML+CSS+JavaScript或Vue或React), 只需要让渲染引擎和JS解释器看懂就行, 不用关注浏览器怎么抹平不同操作系统的差异, 也不用关注不同操作系统怎么抹平不同cpu不同设备的差异. </p>
<p>然而浏览器是有一些弊端的, 我认为主要在3个方面：</p>
<ol>
<li>没有沉浸式体验</li>
<li>没有足够的调用硬件的权限</li>
<li>性能不够好</li>
</ol>
<p>问题1主要是指浏览器在使用时带有边框, 且没有很好的离线缓存控制和消息推送机制, 也没有操作系统风格的UI, 这样会让使用者有一种”临时性使用”的感觉, 而没有沉浸式的体验. 这种弊端尤其体现在移动端. </p>
<p>问题2是指前端代码总是需要通过浏览器来获取硬件资源, 而出于各种考虑和限制, 浏览器能给前端的资源不够充足, 前端是没有较大的调用系统资源权限的. </p>
<p>问题3主要是指JavaScript是一种解释型语言, 每次运行都需要解释一遍, 不如编译型语言开发的软件运行有效率. 虽然有诸如JIT机制的引入, 也不能从根本上解决这个问题. </p>
<p>以上3个问题都有分别的解决方法. 专门针对问题1, 有PWA, 小程序等; 专门针对问题2, 有nodejs; 专门针对问题3, 有WebAssembly. </p>
<h2 id="针对前端技术领域的跨平台技术"><a href="#针对前端技术领域的跨平台技术" class="headerlink" title="针对前端技术领域的跨平台技术"></a>针对前端技术领域的跨平台技术</h2><p>针对前端技术领域的跨平台技术, 按说是应该针对以上3点问题都有解决方案的, 目前来说, 主流的技术有Electron, React Native, Weex和Cordova这几个.</p>
<ul>
<li><p>Electron</p>
<p>  Electron跨的是Windows/MacOS/Linux操作系统. Electron整合了nodejs端和浏览器端. 相对于浏览器, Electron的主进程有更大的权限, JavaScript解释器可以直接操作系统资源, 进行存储, 网络, 消息推送等操作. Electron也允许开发者自定义外壳, 增强用户沉浸感体验. 所以Electron解决了1和2的问题. </p>
<p>  Electron并没有针对问题3的解决方案, 由Electron打包出来的应用和浏览器中的网页没有本质上的性能差异. </p>
</li>
<li><p>React Native</p>
<p>  React Native跨的是Android/iOS操作系统. Electron不再采用浏览器的架构, 取消了浏览器渲染引擎, 仅保留JavaScript解释器, 通过Bridge来和系统原生的api进行对接. 这一思路和Electron是有不同的, Electron是保留了浏览器渲染引擎, 通过浏览器渲染引擎来调用操作系统的图形接口, 而React Native取消了浏览器渲染引擎, 使用系统原生渲染方法来页面. 这样一来, 页面的显示更加原生, 原生的渲染速度和渲染效果会比使用浏览器浏览器渲染引擎要好一些; 同时JavaScript也获得了更大的硬件权限. React Native基本解决了问题1和2. </p>
<p>  React Native在问题3上没有本质上的改观, 因为App还是在运行时JavaScript解释运行. </p>
</li>
</ul>
<p>对比React Native和Electron, 对于前端的浏览器架构这种”制度”, 可谓一个是改革派, 一个是改良派. React Native直接投奔原生语言, 天然带有”沉浸”, “获得系统资源”优点, 不走浏览器线. Electron保留了浏览器机制, 结合nodejs技术, 也可以获得”沉浸”, “获得系统资源”等特点. </p>
<p>Weex了解不多, 我把它理解成使用Vue的React Native. 而Cordova, 我把它理解为移动平台的Electron, 但是它给渲染端的JavaScript增加了一些访问系统资源的api(Electron是通过对接nodejs来实现的), 而如果您想自定义系统功能的话, 需要使用该平台的开发语言.</p>
<p>至于使用这些技术开发时的代码能不能部署到Web端, 首先要确保软件不能有访问系统资源(如读写文件)的功能, 不能调用Api, 也就是说软件是个静态展示类页面. 在这个前提下, Electron, Cordova和Weex的前端部分代码基本可以在Web端重用, 而React Native的写法和React有些差别, 不太好重用在Web端.</p>
<p>另一方面, 当前的前端向跨平台技术并没有解决解释型语言的性能问题. 如果想要”提高性能”, 思路都是一样的：找到接近底层但又和操作系统平台无关的一个Level. 未来如果WebAssembly或类似的技术可以成熟地应用, 那这一问题其实也就一定程度上解决了. </p>
<table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">跨的平台</th>
<th align="center">JavaScript解释器</th>
<th align="center">渲染引擎</th>
<th align="center">与系统交互方式</th>
<th align="center">页面开发技术</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Electron</td>
<td align="center">Windows/ MacOS/ Linux</td>
<td align="center">V8</td>
<td align="center">Blink</td>
<td align="center">通过Web Api和系统层级的nodejs交互</td>
<td align="center">任意前端技术</td>
</tr>
<tr>
<td align="center">Cordova</td>
<td align="center">iOS/ Android</td>
<td align="center">JavaScriptCore(iOS)/ V8(Android)</td>
<td align="center">Webkit(iOS)/ Blink(Android)/自定义</td>
<td align="center">通过特定的Api和系统层级的Native Code(Java, Swift)交互</td>
<td align="center">任意前端技术</td>
</tr>
<tr>
<td align="center">React Native</td>
<td align="center">iOS/ Android</td>
<td align="center">JavaScriptCore</td>
<td align="center">移动平台原生引擎</td>
<td align="center">通过特定的Api和系统层级的Native Code(Java, Swift)交互</td>
<td align="center">React</td>
</tr>
<tr>
<td align="center">Weex</td>
<td align="center">iOS/ Android</td>
<td align="center">JavaScriptCore(iOS)/ V8(Android)</td>
<td align="center">移动平台原生引擎</td>
<td align="center">通过特定的Api和系统层级的Native Code(Java, Swift)交互</td>
<td align="center">Vue</td>
</tr>
</tbody></table>
<h2 id="跨平台与性能之间冲突的折中办法"><a href="#跨平台与性能之间冲突的折中办法" class="headerlink" title="跨平台与性能之间冲突的折中办法"></a>跨平台与性能之间冲突的折中办法</h2><p>我们知道, 高级编程语言有编译型和解释型两个基本类型, 前者以C/C++为代表, 后者以python, JavaScript为代表. 编译型语言会将代码转换成平台特定的机器码来执行, 所以<strong>速度快</strong>, 但是如果想要跨平台, 就需要<strong>分别编译</strong>(如Qt), 或者干脆<strong>分别编写</strong>; 解释型语言会边解释边运行, 好处是是可以<strong>跨平台</strong>, 但是这样反复把高级语言解释成机器码的过程导致<strong>性能偏低</strong>.</p>
<p>解释型语言执行效率低, 其原因在于每次都有解释过程. 由于平台不同, 所以不能事先解释. 那还有一个策略就是运行时优化, 把总是反复解释的代码片段记录下来, 下次用到的时候直接执行它的机器码, 省去解释过程, 这就是<code>JIT</code>技术. 在浏览器中, JIT技术碰到一个问题, 就是JavaScript的变量是无类型的, 导致上次的机器码可能不能重用, 而只能再次解释. 所以一个思路是把JavaScript改造成强类型语言, 这就是TypeScript.</p>
<p>和JIT技术不同, 另一种思路是, 我们为什么不直接把预先编译好的字节码放到浏览器里执行? 这里的根本问题在于, 需要<strong>跨客观存在的不同硬件平台, 并且使程序高性能运行</strong>. 解释型语言跨平台能力强, 然而解释高级语言是需要成本的; 编译型语言开发程序性能较好, 但是需要多次编译成机器码才能适应多个平台. 在高级语言和机器码的两极上, 我们需要找到一个平衡点. 这个点要尽量接近底层的机器码, 以减少解释过程的时间, 尽量解决性能问题; 同时它还要统筹好不同平台的差异, 向上承载的语言必须是基本和平台无关的. 开发时使用高级语言(开发者喜欢的语言, 开发生态好的语言, 适合项目开发的语言)开发, 在解释运行环境下开发(实时调试), 部署时转换成这个中间代码, 提高程序运行性能.</p>
<p><code>WebAssembly</code>就是按照这个思路来设计的, 我不去管弱类型的JavaScript, 而用C++这样的强类型语言开发(原则上TypeScript也是可以的), 通过编译器编译成wasm字节码, 在程序运行的时候wasm字节码会被解释成机器码, 并引入JIT机制进一步改善性能.</p>
<p>Web的成功和它的跨平台属性关系密切, 如果再解决其性能较原生应用偏低的问题, 那Web技术会再一次大放异彩, 更加擅长编写复杂软件. 抛开Web领域, JVM的设计也是遵循这个思路的, 即Java等高级语言编译成class虚拟机器码, 再由JIT虚拟机解释class虚拟机器码. 可以看到, 综合利用编译和解释的优点, 是在不同平台下保持便捷开发和程序高效运行的有效方法.</p>
<p><img src="programming_language.svg" alt="编译型语言和解释型语言"></p>
<h2 id="其他跨平台技术"><a href="#其他跨平台技术" class="headerlink" title="其他跨平台技术"></a>其他跨平台技术</h2><p>以上只是针对由前端技术领域(HTML+CSS+JavaScript)制作图形界面软件的跨平台技术, 此外, 使用其他语言, 开发软件(图形&amp;命令行)的主流跨平台技术, 主要有以下这些. </p>
<p>首先是C/C++(以下统称C++). 如果仅使用C标准库, 由于这个库在Windows/MacOS/Linux上都有, 所以这样的C++代码在不同平台上分别编译后形成的命令行可执行文件, 都是能运行的. 而如果需要调用系统Api, 那么需要一个工具, 把使用系统Api的方式统一起来, 比如说–Qt. Qt就是一个把操作系统的不同Api抹平的开发套件, 一般来说用来开发Windows/MacOS/Linux跨平台图形应用. Qt开发应用仍然需要分别编译.</p>
<p>Dart语言的Flutter技术, 我感觉和Qt在机理上是差不多的, 但是它是跨iOS/Android/Web平台的. Dart是编译型语言, 但是应用于Web平台时是把Dart翻译成JavaScript, 以解释型语言运行的.</p>
<p>再来看一下Java, Java是解释型语言, 当然更确切的说法是Java是(混合编译的)解释型语言, class字节码是Java语言的中间代码, 运行于JVM上. 和Qt不同, JVM在不同操作系统上向上暴露的接口是基本相同的, 而Java转换成的class字节码在运行时还是需要根据平台的不同而解释运行的.</p>
<p>Python也是一种(混合编译的)解释型语言, 和Java的思路是一样的, Python转换成的字节码主要有两种, 一种运行在PVM上, 一种可以运行在JVM上.</p>
<p>nodejs上运行的JavaScript并没有字节码的概念, 是(纯)解释型语言, 不过为了提高性能, 是可以直接调用exe文件的.</p>
]]></content>
      <categories>
        <category>技术漫谈</category>
      </categories>
      <tags>
        <tag>跨平台</tag>
        <tag>Electron</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>MusicMaker编写记录1-Webpack配置与项目搭建</title>
    <url>/blog/2021/01/04/MusicMaker%E7%BC%96%E5%86%99%E8%AE%B0%E5%BD%951-Webpack%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>MusicMaker是我打算做的一个可以<strong>音乐展示</strong>, <strong>即时演奏</strong>和<strong>简单编曲</strong>的软件, 这是我记录编写过程的文章.</p>
<a id="more"></a>

<hr>
<h2 id="MusicMaker简介"><a href="#MusicMaker简介" class="headerlink" title="MusicMaker简介"></a>MusicMaker简介</h2><p>MusicMaker是我打算做的一个可以<strong>音乐展示</strong>, <strong>即时演奏</strong>和<strong>简单编曲</strong>的软件, 打算使用Web前端技术做, 跨Web和所有Native端. 做这个项目的目的有两个, 一个是为了实现自己的这个想法, 另一个是练习Web前端技术. 而且这种自己从头规划, 慢慢制作是很有成就感的!</p>
<p>自己玩的项目, 不好说啥时候更新, 大家看个乐就行了.</p>
<p><strong>项目地址: <a href="https://github.com/sien75/musicmaker">https://github.com/sien75/musicmaker</a></strong></p>
<p><strong>本次commit版本: <a href="https://github.com/sien75/musicmaker/tree/7d6d162c407fc87a386fa6d4d4189c6ea2367150">https://github.com/sien75/musicmaker/tree/7d6d162c407fc87a386fa6d4d4189c6ea2367150</a></strong></p>
<p><strong>Docs: <a href="https://sien75.github.io/musicmaker">https://sien75.github.io/musicmaker</a></strong></p>
<hr>
<h2 id="项目设想"><a href="#项目设想" class="headerlink" title="项目设想"></a>项目设想</h2><p>之前第一版的MusicMaker分为两个部分: LivePlay和Arranger. LivePlay部分是一个键盘乐器, 可以即时演奏, 算是基本完成的. Arranger部分嘛…, 我是想做一个编曲+展示的页面. 想做的功能挺多的, 但是做到的只是个半成品.</p>
<p><img src="./musicmaker_v1.png" alt="MusicMaker"></p>
<p>第一版使用的技术是最基础的HTML+CSS+JavaScript, 搁置了很久, 但是我是一直想把这个东西做下去的. 两年过去了, 我现在已经接触到了更多的前端技术, 所以我打算另起炉灶, 用新技术重新构思, 做第二版!</p>
<p>这次我带来了几个超强的武器: Webpack, React, TypeScript. 项目搭建伊始要规划的事很多, 但主要工作就是把Webpack配置好. 在Webpack的配置过程中, 就能把项目的基本要素都串起来.</p>
<p>不过一切的开始, 应该是 – 新建一个文件夹:</p>
<p><img src="./new_folder.png" alt="新建文件夹"></p>
<p>当然, 由于我是从Github上直接拉下来的项目, 所以是有git版本控制的. 我把项目中的文件和文件夹放到另一个分支备份, 然后把master分支清空了.</p>
<p>如果是对于一个没有git的空文件夹, 那么第一步无疑是执行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>在有了git的版本控制后, 我们接下来要干什么呢? 没错, 接下来要进行npm初始化, 生成<code>package.json</code>文件, 这个文件是node项目的核心文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>这样一个node项目就初始化完成了! 接下来进行目录规划:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|- musicmaker</span><br><span class="line">    |- build</span><br><span class="line">        |- lib</span><br><span class="line">            |- ...</span><br><span class="line">        |- doc</span><br><span class="line">            |- ...</span><br><span class="line">    |- src</span><br><span class="line">        |- ...</span><br><span class="line">    |- examples</span><br><span class="line">        |- ...</span><br><span class="line">    |- public</span><br><span class="line">        |- ...</span><br><span class="line">    |- package.json</span><br><span class="line">    |- .gitignore</span><br></pre></td></tr></table></figure>
<ul>
<li><code>src</code>, 目录下是MusicMaker的库原始代码, 这一部分是Musicmaker的核心功能部分</li>
<li><code>examples</code>, 目录下是对MusicMaker库的使用, 也就是说这一部分是用于向其他人介绍使用方法, 并展示效果的</li>
<li><code>build/lib</code>, 目录下是生成的库文件</li>
<li><code>build/doc</code>, 目录下是构建好的<code>examples</code>页面(即Docs页), 这一部分会直接部署到项目的GitHub Page上</li>
</ul>
<hr>
<h2 id="如何构建"><a href="#如何构建" class="headerlink" title="如何构建"></a>如何构建</h2><p>一个项目的基础骨架搭建好了, 接下来就是注入灵魂的时候了:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>我打算使用Webpack构建Docs页, 并用Webpack构建既可以使用<code>&lt;script&gt;</code>标签引入, 也可以使用<code>import</code>引入的MusicMaker库.</p>
<p>但是使用MusicMaker库依赖React, 直接在<code>&lt;script&gt;</code>标签里写JSX, 不是一件明智的行为. 所以我取消了库可以用<code>&lt;script&gt;</code>标签引入的打算.</p>
<p>我一开始也打算用Webpack构建MusicMaker库, 但是Webpack会把一个entry打包成一个文件输出, 无法保持原目录结构, 也无法生成.d.ts文件, 所以构建库需要另选工具.</p>
<p>使用Typescript的命令行工具<code>tsc</code>可以直接生成<code>.d.ts</code>文件, 所以这是一个构建库的不错的工具. 对于库来说CSS和JavaScript的构建是两条生产线, 我使用<code>sass</code>命令行工具来实现<code>.scss</code>文件的编译.</p>
<p><code>package.json</code>内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --config webpack/config.doc.dev.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config webpack/config.doc.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build:lib&quot;</span>: <span class="string">&quot;rm -rf build/lib/* &amp;&amp; tsc --project tsconfig.lib.json &amp;&amp; sass src:build/lib --no-source-map&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Webpack的主要功能有两个: A – “开发”到”发布”的转换, B – 实时观察”开发”的效果. 在这里面, <code>start</code>是使用的B功能, <code>build</code>是使用的A功能.</p>
<p><code>start</code>是会以<code>examples</code>文件夹的文件为入口, 而<code>examples</code>内的文件会依赖<code>src</code>内的核心库文件. 这个是用于实时开发, 观察Docs页的效果. 当然我也会借用此来调试MusicMaker库.</p>
<p><code>build</code>就是构建Docs页, <code>start</code>是即时开发, 而<code>build</code>则是输出构建好的文件, 构建好的页面会直接部署到Github Page上. 和<code>start</code>一样, <code>build</code>会以<code>examples</code>文件夹的文件为入口, 而<code>examples</code>内的文件会依赖<code>src</code>内的核心库文件.</p>
<p><code>build:lib</code>是构建MusicMaker库的命令, 这个命令都会以<code>src</code>目录下的文件为入口, 涉及<code>src</code>目录下的文件, 但不会涉及<code>examples</code>下的文件. 这里3个命令作用为:</p>
<ul>
<li><code>rm -rf build/lib/*</code>, 删除原有的库文件</li>
<li><code>tsc --project tsconfig.lib.json</code>, 使用<code>tsc</code>编译<code>.tsx</code>生成<code>.js</code>和<code>.d.ts</code>文件</li>
<li><code>sass src:build/lib</code>, 使用<code>sass</code>编译<code>.scss</code>生成<code>.css</code></li>
</ul>
<p>项目的Webpack配置文件都会放在<code>webpack</code>文件夹内, <code>entries.js</code>, <code>plugins.js</code>和<code>loaders.js</code>这3个基本的配置文件, 是会被各<code>config.xxx.js</code>依赖的.</p>
<p>项目使用Babel来配合Webpack编译<code>.tsx</code>文件, Babel配置文件为项目根目录下的<code>.babelrc</code>文件.</p>
<p>项目的TypeScript配置文件为<code>tsconfig.json</code>, 不过这个只是用于智能提醒编辑器的, 真正的<code>tsc</code>编译时使用的配置文件是<code>tsconfig.lib.json</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上述提及的配置文件位置如下:</span><br><span class="line">|- musicmaker</span><br><span class="line">    |- ...</span><br><span class="line">    |- webpack</span><br><span class="line">        |- entries.js</span><br><span class="line">        |- plugins.js</span><br><span class="line">        |- loaders.js</span><br><span class="line">        |- config.doc.dev.js</span><br><span class="line">        |- config.doc.js</span><br><span class="line">        |- config.lib.js</span><br><span class="line">    |- package.json</span><br><span class="line">    |- .babelrc</span><br><span class="line">    |- tsconfig.json</span><br><span class="line">    |- tsconfig.lib.json</span><br></pre></td></tr></table></figure>

<p>接下来我会详细描述项目的各个配置项.</p>
<hr>
<h2 id="Webpack配置-entries-js"><a href="#Webpack配置-entries-js" class="headerlink" title="Webpack配置 - entries.js"></a>Webpack配置 - entries.js</h2><p>先从Webpack的配置说起吧.</p>
<p>首先看<code>entries.js</code>, 我会把所有的<code>entry</code>和<code>output</code>以及<code>resolve</code>写在这里. 基本内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">&#x27;../examples/index.tsx&#x27;</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../build/doc&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">        alias: &#123;</span><br><span class="line">            musicmaker: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然Docs页是个多页面情况, 肯定不止一个entry, 以后会动态添加的. 设置别名<code>musicmaker</code>是为了在引入MusicMaker库的时候更方便, 更接近使用场景:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置的话</span></span><br><span class="line"><span class="keyword">import</span> MusicMaker <span class="keyword">from</span> <span class="string">&#x27;musicmaker&#x27;</span>;</span><br><span class="line"><span class="comment">// 不设置的话</span></span><br><span class="line"><span class="keyword">import</span> MusicMaker <span class="keyword">from</span> <span class="string">&#x27;../musicmaker&#x27;</span>;</span><br><span class="line">impoer MusicMaker <span class="keyword">from</span> <span class="string">&#x27;../../../musicmaker&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Webpack配置-plugins-js"><a href="#Webpack配置-plugins-js" class="headerlink" title="Webpack配置 - plugins.js"></a>Webpack配置 - plugins.js</h2><p>我会把所有<code>plugins</code>和<code>optimization</code>的配置放在这里.</p>
<p>项目需要安装4个插件: html-webpack-plugin, clean-webpack-plugin, mini-css-extract-plugin和css-minimizer-webpack-plugin, 首先安装它们:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin@next clean-webpack-plugin mini-css-extract-plugin css-minimizer-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="HTML模板插件和清空输出文件夹插件"><a href="#HTML模板插件和清空输出文件夹插件" class="headerlink" title="HTML模板插件和清空输出文件夹插件"></a>HTML模板插件和清空输出文件夹插件</h3><p>先看一下前两个插件, <code>plugins.js</code>文件包含以下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cwp = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>).CleanWebpackPlugin)();</span><br><span class="line"><span class="keyword">const</span> hwp = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>))(&#123;</span><br><span class="line">    title: <span class="string">&#x27;MusicMaker&#x27;</span>,</span><br><span class="line">    favicon: path.resolve(__dirname, <span class="string">&#x27;../public/favicon.ico&#x27;</span>),</span><br><span class="line">    template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> plugins = [cwp, hwp];</span><br></pre></td></tr></table></figure>

<p>CleanWebpackPlugin是用来在清除旧的构建文件的, 而HtmlWebpackPlugin是创建主html文件的.</p>
<h3 id="JavaScript代码分离"><a href="#JavaScript代码分离" class="headerlink" title="JavaScript代码分离"></a>JavaScript代码分离</h3><p>代码分离是Webpack的一个很有用的功能. 试想一下, 两个entry共用一个依赖库, 然后把依赖库各自打包到自己的bundle文件里. 这种代码重复的情况, 造成了打包体积过大, 浪费存储和网络资源, 且很不优雅.</p>
<p>我们在这里用到了<code>SplitChunksPlugin</code>这个插件(无需额外安装), 这个插件可以把共用的依赖库提取出来, 使一份代码仅被打包一次, 避免JavaScript代码重复. 在<code>plugins.js</code>里新加入下面的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins.js</span></span><br><span class="line"><span class="keyword">const</span> optimization = &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CSS代码分离"><a href="#CSS代码分离" class="headerlink" title="CSS代码分离"></a>CSS代码分离</h3><p>同样的, 项目也需要对CSS代码进行分离操作. 对CSS代码分离需要修改<code>plugins</code>和<code>loader</code>两部分, 出于速度方面的考虑, 仅在生产模式启用这一功能:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins.js</span></span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> mcepFun = <span class="function">() =&gt;</span> <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>))(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> plugins = devMode ? [cwp, hwp] : [cwp, hwp, mcepFun()];</span><br></pre></td></tr></table></figure>

<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>Webpack5会对生产模式下输出的JavaScript代码进行压缩, 这里需要配置的是CSS的代码压缩. 这里使用到的插件是<code>css-minimizer-webpack-plugin</code>, 修改<code>plugins.js</code>代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins.js</span></span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cmwpFun = <span class="function">() =&gt;</span> <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>))();</span><br><span class="line"><span class="keyword">const</span> optimization = &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: devMode ? [<span class="string">&#x27;...&#x27;</span>] : [<span class="string">&#x27;...&#x27;</span>, cmwpFun()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h3><p>至此, <code>plugins.js</code>完成, 完整的配置文件如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugins.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cwp = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>).CleanWebpackPlugin)();</span><br><span class="line"><span class="keyword">const</span> hwp = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>))(&#123;</span><br><span class="line">    title: <span class="string">&#x27;MusicMaker&#x27;</span>,</span><br><span class="line">    favicon: path.resolve(__dirname, <span class="string">&#x27;../public/favicon.ico&#x27;</span>),</span><br><span class="line">    template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> mcepFun = <span class="function">() =&gt;</span> <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>))(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> cmwpFun = <span class="function">() =&gt;</span> <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>))();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = devMode ? [cwp, hwp] : [cwp, hwp, mcepFun()];</span><br><span class="line"><span class="keyword">const</span> optimization = &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: devMode ? [<span class="string">&#x27;...&#x27;</span>] : [<span class="string">&#x27;...&#x27;</span>, cmwpFun()],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; plugins, optimization &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Webpack配置-loaders-js"><a href="#Webpack配置-loaders-js" class="headerlink" title="Webpack配置 - loaders.js"></a>Webpack配置 - loaders.js</h2><p>接下来是很重要的Loader配置, 目前我想到的就是解析<code>.tsx</code>和<code>.scss</code>, 也就是解析TypeScript, React和Sass, 后续如果需要解析其他类型文件的话再进一步修改. 首先把本体们安装上:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D typescript</span><br><span class="line">npm i react react-dom</span><br><span class="line">npm i -D sass</span><br></pre></td></tr></table></figure>

<h3 id="解析-tsx"><a href="#解析-tsx" class="headerlink" title="解析.tsx"></a>解析<code>.tsx</code></h3><p>我会使用Babel对TypeScript, React和ES新特性进行解析, 安装命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D babel-loader @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript</span><br><span class="line">npm i core-js regenerator-runtime</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@babel/core</code>是Babel的核心模块</li>
<li><code>@babel/preset-react</code>是Babel用于编译React的preset</li>
<li><code>@babel/preset-typescript</code>是Babel用于编译TypeScript的preset</li>
<li><code>core-js</code>和<code>regenerator-runtime</code>是为了使用如Promise等新特性而需引入的polyfill</li>
<li><code>babel-loader</code>是Webpack使用Babel的Loader</li>
</ul>
<p>现在编写<code>loader.js</code>配置文件, 内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> include = [</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;../examples&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(t|j)sx?$/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                options: &#123; <span class="attr">cacheDirectory</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">                include,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在项目根目录创建Babel的配置文件<code>.babelrc</code>, 内容如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;targets&quot;</span>: <span class="string">&quot;defaults&quot;</span>, <span class="comment">// 以主流浏览器为构建目标</span></span><br><span class="line">                <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>, <span class="comment">// 按需引入polyfill</span></span><br><span class="line">                <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span>, <span class="comment">// core-js的版本</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@babel/preset-typescript&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">Babel的`presets`是有顺序的, 按照从下到上的顺序解析.</span><br></pre></td></tr></table></figure>

<h3 id="解析-scss"><a href="#解析-scss" class="headerlink" title="解析.scss"></a>解析<code>.scss</code></h3><p>解析Sass需要安装3个Loader:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D sass-loader css-loader style-loader</span><br></pre></td></tr></table></figure>
<p>它们的作用分别如下:</p>
<ul>
<li><code>sass-loader</code>, 把Sass编译成CSS</li>
<li><code>css-loader</code>, 把CSS转换成JavaScript</li>
<li><code>style-loader</code>, 把JavaScript转换成&lt;style&gt;节点</li>
</ul>
<p>在生产环境把”CSS in JavaScript”转换成CSS文件需要<code>mini-css-extract-plugin</code>插件, 这个我们在代码分离部分说过.</p>
<p>安装完Loader后, 再编写loaders.js文件, 新增解析Sass的部分:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> mcepLoaderFun = <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>).loader;</span><br><span class="line"><span class="keyword">const</span> include = [</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    path.resolve(__dirname, <span class="string">&#x27;../examples&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(t|j)sx?$/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                options: &#123; <span class="attr">cacheDirectory</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">                include,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    devMode ? <span class="string">&#x27;style-loader&#x27;</span> : mcepLoaderFun(),</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">                ],</span><br><span class="line">                include,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Webpack实际配置文件"><a href="#Webpack实际配置文件" class="headerlink" title="Webpack实际配置文件"></a>Webpack实际配置文件</h2><p>前面说的是基础的配置, 只不过是分到了3个文件里, 现在要把这3个文件整合起来. 项目有2个Webpack命令, 需要2个配置文件, 内容很好理解:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.doc.js</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    ...require(<span class="string">&#x27;./entries&#x27;</span>),</span><br><span class="line">    ...require(<span class="string">&#x27;./plugins&#x27;</span>),</span><br><span class="line">    ...require(<span class="string">&#x27;./loaders&#x27;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.doc.dev.js</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    ...require(<span class="string">&#x27;./entries&#x27;</span>),</span><br><span class="line">    ...require(<span class="string">&#x27;./plugins&#x27;</span>),</span><br><span class="line">    ...require(<span class="string">&#x27;./loaders&#x27;</span>),</span><br><span class="line">    devtool: <span class="string">&#x27;eval-cheap-module-source-map&#x27;</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        contentBase: <span class="string">&#x27;../build/doc&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>config.doc.dev.js</code>里, 要配置好用于实时开发的<code>devtool</code>和<code>devServer</code>.</p>
<hr>
<h2 id="TypeScript配置"><a href="#TypeScript配置" class="headerlink" title="TypeScript配置"></a>TypeScript配置</h2><p>使用Babel的TypeScript插件是不会顾及<code>tsconfig.json</code>的内容的, 我们这里有2个TypeScript配置文件, 内容基本一致. <code>tsconfig.json</code>文件内容如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// 支持react</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成.d.ts文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./build/lib&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;<span class="attr">&quot;musicmaker&quot;</span>: [<span class="string">&quot;src&quot;</span>]&#125;, <span class="comment">// 配合baseUrl, 设置别名</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src&quot;</span>, <span class="string">&quot;examples&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">我们的`src`和`examples`目录都使用了TypeScript, 为了让VSCode正确提示不报错, 所以`include`字段里包含了这连个目录. 但是, 使用`tsc`构建的时候, 只构建`src`目录, 所以需要另写一份配置文件, 更改的地方如下:</span><br><span class="line">```json</span><br><span class="line"><span class="comment">// tsconfig.lib.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于VSCode插件"><a href="#关于VSCode插件" class="headerlink" title="关于VSCode插件"></a>关于VSCode插件</h2><p>我在项目里用到了下面的插件:</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>ESLint是用于JavaScript/TypeScript/JSX/TSX/CSS/Sass等的语法检测的, 可以有效防止一些错误, 需先通过npm安装:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D eslint</span><br></pre></td></tr></table></figure>
<p>我把ESLint安装到了项目本地目录, 你也可以把它安到全局. 安装完成以后, 初始化ESLint. 在项目根目录执行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure>
<p>根据项目选择合适的选项, 比如我的这个项目是要用到React和TypeScript的, 那相应的选项要选择true. 命令执行后会生成一个<code>.eslintrc.js</code>文件.</p>
<p>之后我们可以安装VSCode的ESLint插件了, 插件会根据<code>.eslintrc.js</code>的配置对项目的文件语法进行检测, 对不符合规则的代码提出警告.</p>
<h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p>安装VSCode的Prettier插件, 可以使代码的风格更加规范, 增强可读性. Prettier并不会对代码的语法进行检测, 它只是去对代码进行无语义变更的格式化.</p>
<p>安装Prettier的命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D prettier</span><br></pre></td></tr></table></figure>

<p>打开VSCode设置的<code>Format On Save</code>, 这样就可以每次保存的时候格式化代码了. 说实话写代码的时候不去关注格式, 之后一个CMD/Ctrl + s, 代码立刻变得漂亮, 这感觉是很棒的.</p>
]]></content>
      <categories>
        <category>MusicMaker编写记录</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
