<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/blog/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/blog/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="/blog/imgs/favicon.png">
    
    
    
<link rel="stylesheet" href="/blog/css/mdui.min.css">
<link rel="stylesheet" href="/blog/css/main.css">
<link rel="stylesheet" href="/blog/css/iconfont.css">

    
    













    
    
    <title>
        
            浏览器基础 | Sien75&#39;s Blog
        
    </title>
    
    
<meta name="generator" content="Hexo 5.1.1"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/blog/" class="mdui-typo-headline">Sien75&#39;s Blog</a>
    <a href="/blog/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/blog/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-2">
        <div class="mdui-list">
            
                
                <a href="/blog/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/blog/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/blog/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/blog/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-2">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="/blog/imgs/avatar.jpg"/>
                
            </div>
            <div class="sidebar-author-name">sien75</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:sien75@icloud.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a target="_blank" rel="noopener" href="https://github.com/sien75" class="mdui-chip-title">GitHub</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-meadow" class="mdui-list-item mdui-ripple">
                            Meadow主题
                        </a>
                    
                </ul>
            </li>
        </ul>

    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/">浏览器基础</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2020-08-31
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2020-09-11
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;<a class="category-link" href="/blog/categories/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">Web前端基础</a>
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=浏览器基础&url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/&pic=https://sien75.github.io/blog/blog/blog/imgs/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=浏览器基础&url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/&via=sien75" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/&title=浏览器基础" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=Sien75&#39;s Blog&title=浏览器基础&summary=&pics=https://sien75.github.io/blog/blog/blog/imgs/favicon.png&url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=https://sien75.github.io/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/&text=浏览器基础" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  <div class="post-tags">
    
      <i class="iconfont icon-tag">
        <a rel="tag" href = /blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/ >浏览器</a>
      </i>
    
  </div>

  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <p>本文包含了浏览器的部分基础内容, 包括浏览器的工作原理, 客户端存储, 以及多线程的相关问题, 不是教程, 不以总结全面为目标, 仅仅是记录下自己觉得有价值的点, 作为参考. 本文包含了很多个人理解, 不一定是正确的, 这是我当前的认知水平.</p>
<a id="more"></a>

<h2 id="浏览器的工作原理概述"><a href="#浏览器的工作原理概述" class="headerlink" title="浏览器的工作原理概述"></a>浏览器的工作原理概述</h2><ol>
<li><p>浏览器的构成.</p>
<p> <img src="./components.png" alt="浏览器的构成"></p>
<p> 浏览器主要由以下几个部分构成:</p>
<ul>
<li>用户界面, 包括地址栏, 前进/后退按钮, 书签菜单等, 即浏览器的”前端”</li>
<li>浏览器引擎, 在用户界面和渲染引擎之间传送指令(说实话我不清楚这一部分的真正角色, 可能各套壳浏览器会修改这一部分吧)</li>
<li><strong>渲染引擎</strong>, 解析HTML和CSS, 并计算页面布局, 确定元素位置</li>
<li>JS解释器, 解释和执行JavaScript代码</li>
<li>网络, 用于网络调用, 比如HTTP请求, 公开了与平台无关的通用接口, 而在底层使用操作系统的网络方法(最终是使用<strong>网卡</strong>)</li>
<li>用户界面后端, 用于绘制基本的窗口小部件, 公开了与平台无关的通用接口, 而在底层使用操作系统的用户界面方法(最终是使用<strong>显卡</strong>)</li>
<li>数据存储, 用于浏览器在硬盘保存数据, 也叫数据持久层(最终是使用<strong>硬盘</strong>)</li>
</ul>
<p> <em>此部分参考了<a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a>.</em></p>
</li>
<li><p>浏览器的工作流程. 下面的图片是在<a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png">原图片</a>的基础上, 加上我自己的理解, 绘制的浏览器工作流程图, 使用的是WebKit渲染引擎.</p>
<p> <img src="./webkit_flow.png" alt="WebKit渲染引擎浏览器工作流程图"></p>
<p> 在上图中, 我们可以清晰地看到浏览器的工作流程.</p>
<ul>
<li>浏览器的工作当然是先从<code>用户界面(User Interface)</code>开始的. 用户的一些操作, 比如点击链接, 输入url跳往指定地址等会触发指令, 通过<code>浏览器引擎(Browser Engine)</code>传往<code>渲染引擎(Render Engine)</code></li>
<li><code>浏览器引擎(Browser Engine)</code>还会从<code>数据持久层(Data Persistence)</code>中取出储存的数据, 如Cookie, 缓存等, 一并送往<code>渲染引擎(Render Engine)</code></li>
<li>在<code>渲染引擎(Render Engine)</code>中, 由<code>loader</code>负责接收指令, 并且根据指令调用<code>网络(Networking)</code>, 获得相应的文件</li>
<li>获得的文件中, HTML部分交由<code>HTML Parser</code>处理, 形成<code>DOM树(DOM Tree)</code>; 样式表部分交由<code>CSS Parser</code>处理, 形成样式规则; JavaScript部分交由<code>JavaScript解释器(JavaScript Interpreter)</code>处理, 把解析结果应用到DOM树和样式规则上. 最终解析完毕的样式规则会附加到DOM树上</li>
<li>之后渲染引擎的<code>布局(Layout)</code>工作, 把包含样式规则的<code>渲染树(Render Tree)</code>转换成包含坐标信息的渲染树. 在首次布局之后, 再次发生的布局被称为<code>重排(Relayout)</code></li>
<li>之后渲染引擎的<code>绘制(Paint)</code>工作, 调用<code>用户界面后端(UI Backend)</code>将每个节点绘制出来. 在首次绘制之后, 再次发生的绘制被称为<code>重绘(Repaint)</code></li>
</ul>
<p> <em>此部分参考了<a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a>.</em></p>
</li>
<li><p>大多数情况下, 我们使用Gecko的术语<code>回流(Reflow)</code>表示重排的过程.</p>
<ul>
<li>渲染树中元素的尺寸, 结构或某些属性发生改变时, 会发生回流. 从上面的流程图可以看到, 回流必然引发重绘</li>
<li>当一些不影响元素在布局流中的位置的属性改变时, 如<code>color</code> <code>visibility</code>, 仅会发生重绘</li>
</ul>
<p>由于频繁的回流和重绘会影响性能, 所以在写代码的时候尽量遵循一定的原则避免频繁的回流和重绘:</p>
<ul>
<li>不使用table布局</li>
<li>避免设置多层样式</li>
<li>避免使用CSS表达式(如<code>calc()</code>)</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上, 否则会引起父元素的频繁回流</li>
<li>避免频繁使用JavaScript操作样式, 应多次一并修改</li>
<li>避免频繁操作DOM, 可创建<code>documentFragment</code>, 在其上面进行DOM操作, 最后附加到DOM树上</li>
</ul>
</li>
<li><p>HTML的解析过程, 是可能会被普通<code>&lt;script&gt;</code>标签的下载和解析阻塞的. 我们知道HTML文件是自上而下解析成DOM的, 当遇到普通<code>&lt;script&gt;</code>标签时, 会暂停HTML解析, 进行相应的JavaScript(下载和)解析, 因为此时JavaScript可能会操作DOM.</p>
<p>CSS不会阻塞HTML解析, 但会阻塞渲染树的生成, 也就是说CSS只有全部解析完毕才会附加到DOM上, 形成渲染树. 然而JavaScript可能会操作样式, 所以浏览器在遇到普通<code>&lt;script&gt;</code>标签之前的CSS时就会暂停HTML解析过程, 也就是说普通<code>&lt;script&gt;</code>标签之前的CSS会阻塞HTML解析, 之后的CSS就不会阻塞HTML解析了. 这其实是因为每个普通<code>&lt;script&gt;</code>解析完之后, 浏览器会渲染一次页面, 所以必须用到之前的CSS.</p>
<p>DOM解析完毕(HTML解析和JavaScript解析的双重结果)时, 触发<code>DOMContentLoaded</code>事件. 当然, 这时的图片啊普通<code>&lt;script&gt;</code>标签之后的CSS啊等资源不一定下载解析完毕, 当所有资源下载解析完毕时, 触发<code>load</code>事件.</p>
<p>异步加载JavaScript的两个方式(可以见我的<a href="https://sien75.github.io/blog/2020/08/12/%E9%83%A8%E5%88%86ES6%E7%9F%A5%E8%AF%86/#Module">部分ES6知识-Module部分</a>)中, defer类会在整个同步代码(HTML和普通<code>&lt;script&gt;</code>标签中的JavaScript)解析完毕之后再解析, 会阻塞<code>DOMContentLoaded</code>事件的触发. 而async类的解析过程会阻塞同步代码解析, 进而阻塞<code>DOMContentLoaded</code>事件的触发, 但是如果在同步代码解析后async类内代码才下载完, 那其就不会阻塞<code>DOMContentLoaded</code>事件的触发了.</p>
</li>
<li><p>下图为浏览器接口示意图(根据我自己的理解画的), 所谓Web API, 就是指使用JavaScript去读(获得)或写(控制)其它单位的方法. 这里的其他单位可能是渲染引擎, 也可能是其他JS线程, 也可能是硬件, 当然最终都是控制的硬件.</p>
<p>每一种访问都有其专门的接口, 在JavaScript里面体现为一种特定的对象类型. 比如你</p>
<ul>
<li>想访问渲染引擎里的DOM, 那就用到了<code>Document</code>类型</li>
<li>想访问Web Worker线程, 那就用到了<code>Worker</code>类型</li>
<li>想在内存里新建一定大小的数据, 那就用到了<code>ArrayBuffer</code>类型</li>
<li>想访问硬盘上的二进制文件, 那就用到了<code>Blob</code>类型</li>
<li>想通过网卡异步访问互联网的内容, 那就用到了<code>XMLHttpRequest</code>类型</li>
</ul>
<p><img src="./interface.png" alt="浏览器接口示意图"></p>
<p>DOM接口和BOM接口是使用EcmaScript进行Web开发的基本Web API, 我们把这两部分和EcmaScript合称JavaScript. 但是由于浏览器的日益复杂, 浏览器本身组成部分和支持的硬件越来越多, 所以仅仅使用DOM和BOM无法满足需求. 在这里我倾向于取JavaScript的狭义, 即JavaScript = EcmaScript.</p>
<p>使用JavaScript(EcmaScript)来操作浏览器以及各种硬件, 需要包括DOM接口和BOM接口在内的各种Web API的扶持, 也就是说, Web API实际上赋予了开发者使用JavaScript(EcmaScript)开发各种功能的Web应用的能力, 是构建于JavaScript(EcmaScript)语言之上的.</p>
</li>
</ol>
<h2 id="客户端存储-–-Storage"><a href="#客户端存储-–-Storage" class="headerlink" title="客户端存储 – *Storage"></a>客户端存储 – *Storage</h2><p>客户端有2个存储数据的对象.</p>
<ul>
<li>localStorage用于长久保存网站数据, 除非手动清除, 不会消失</li>
<li>sessionStorage用于临时保存网站数据, 关闭窗口或标签页时数据就会被删除<br>两个对象使用方法都一样, 以localStorage为例:  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.data = <span class="number">1</span>;<span class="comment">//设置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.data);<span class="comment">//读取(结果为字符串)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">localStorage</span>.data;<span class="comment">//删除</span></span><br><span class="line"><span class="built_in">localStorage</span>.clear();<span class="comment">//全部清除</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="客户端存储-–-IndexedDB"><a href="#客户端存储-–-IndexedDB" class="headerlink" title="客户端存储 – IndexedDB"></a>客户端存储 – IndexedDB</h2><p><em>此部分参考了<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/07/indexeddb.html">https://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></em><br>由于cookie大小不能超过4KB, 且每次请求都会发送给服务器; *Storage也有大小限制, 不提供搜索功能, 不能建立自定义的索引. 所以需要一种新的解决方案. IndexedDB是一种NoSQL, 可以在客户端存储大量数据, 还支持二进制储存.</p>
<ol>
<li><p>基本概念:</p>
<ul>
<li>数据库(IDBDatabase对象), 数据总容器, 可以建立多个</li>
<li>对象仓库(IDBObjectStore对象), 每个数据库中包含若干个对象仓库, 类似于SQL中的表</li>
<li>索引(IDBIndex对象), 类似于SQL中的列名</li>
<li>事务(IDBTransaction对象), 数据的增删改查都要通过它完成</li>
<li>操作请求(IDBRequest对象), 打开或新建数据库时获取到的对象</li>
<li>主键, 即默认的索引, 可以指定为某个属性, 也可以是自动生成的递增数据编号</li>
</ul>
</li>
<li><p>打开, 新建和修改数据库<br> 通过以下方法打开, 新建或修改数据库:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = indexedDB.open(dbName, dbVerion);</span><br></pre></td></tr></table></figure>
<p> 不指定dbVersion, 则使用当前版本. 返回的request是一个<code>IDBRequest对象</code>.</p>
<ul>
<li>如果操作成功则会触发success事件, 此即打开</li>
<li>如果指定的版本高于当前版本, 且操作成功则会触发upgradeneeded事件, 此即修改</li>
<li>如果指定的数据库名字不存在, 且操作成功则会触发upgradeneeded事件, 此即新建</li>
<li>如果操作错误, 则会触发error事件<br>3个事件的使用如下:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;<span class="comment">//这是个`IDBDatabase对象`</span></span><br><span class="line">    db.objectStoreNames;<span class="comment">//获得该数据库下所有的</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//如果要新建数据库的话, 按下面步骤操作</span></span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;</span><br><span class="line">    <span class="keyword">let</span> objStore = db.createObjectStore(<span class="string">&#x27;newOS&#x27;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);<span class="comment">//这个是`IDBObjectStore对象`</span></span><br><span class="line">    objStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;);<span class="comment">//这个是`IDBIndex对象`</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.target.error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据库内对象仓库的增删改查<br> 对对象仓库进行增删改查, 需要先获取该<code>IDBObjectStore对象</code>. 在新建对象仓库时可以通过<code>db.createObjectStore</code>返回值获得该对象, 但是不能这样直接使用, 而是要通过事务对象<code>IDBTransaction对象</code>来获得<code>IDBObjectStore对象</code>. 通过如下方法获得事务对象:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tsc = db.transaction([<span class="string">&#x27;objectStorageName&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p> 其中db是上面的<code>IDBDatabase对象</code>, 之后就可以获取到相应的<code>IDBObjectStore对象</code>了:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objStore = tsc.objectStore(<span class="string">&#x27;objectStorageName&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p> 实际的query操作:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> query = objStore.add(&#123;<span class="attr">name</span>: <span class="string">&#x27;sam&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;);<span class="comment">//增</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.delete(<span class="number">1</span>);<span class="comment">//删, 使用主键值作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.put(&#123;<span class="attr">name</span>: <span class="string">&#x27;amy&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;, <span class="number">1</span>);<span class="comment">//改, 第二个参数是主键值</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.get(<span class="number">1</span>);<span class="comment">//查, 使用主键值作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.index(<span class="string">&#x27;name&#x27;</span>).get(<span class="string">&#x27;sam&#x27;</span>);<span class="comment">//查, 使用索引作为参数</span></span><br><span class="line"><span class="keyword">let</span> query = objStore.openCursor();<span class="comment">//遍历, 监听query的success事件</span></span><br><span class="line"><span class="comment">//以上query都有success和error事件, 都是`IDBRequest对象`, 在监听函数内部通过e.target.result或this.result或query.result访问到结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用监听函树实例(遍历):</span></span><br><span class="line">query.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cursor = e.target.reuslt;</span><br><span class="line">    <span class="keyword">if</span>(cursor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(cursor.value, cursor.key);</span><br><span class="line">        cursor.continue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li><p>浏览器的进程和线程</p>
<p><code>进程(process)</code>是操作系统分配资源的最小单位, <code>线程(thread)</code>是程序执行的最小单位; 进程由线程组成, 进程间相互独立, 同一进程的线程之间共享资源; 线程切换比进程快.</p>
<p>Chrome浏览器使用的是多进程隔离不同的标签页, 在每一个进程中, 有着渲染引擎线程, JavaScript主线程, 定时器线程, 事件线程以及网络线程等. 除了各标签页进程外, Chrome还有主进程, 扩展程序进程等.</p>
</li>
<li><p><code>Web Worker</code>和<code>Service Worker</code></p>
<p>JavaScript是设计用来操作DOM的语言, 为了避免复杂性, JavaScript是一种<strong>单线程</strong>语言. 由于JavaScript主线程和渲染引擎线程互斥, 所以如果JavaScript主线程上有一些耗时的代码, 那么必然会阻塞其他代码的执行, 也会阻塞页面的渲染. 所以, 如果我们需要运行一些耗时的代码时, 完全可以开辟一个新的线程, 这就是<code>Web Worker</code>. <code>Web Worker</code>实际上是存在于标签页进程内部的线程.</p>
<p>然而<code>Web Worker</code>是跟随标签页进程的, 当标签页关闭了, 其工作也就结束了. 如果想持久化, 那就需要<code>Service Worker</code>.</p>
<p><code>Service Worker</code>本身也是一个新的线程, 但是它是独立于标签页线程的, 标签页的关闭不会导致其结束. 而且, <code>Service Worker</code>还被赋予中间人代理的权利, 即抓取网络请求并作出修改, 再送给渲染引擎的权利. 借着这两点, 它可以做到对网络请求文件的缓存, 使页面可以离线访问. 它还有消息推送的能力, 使得Web网页变得更像一个本地应用.</p>
</li>
<li><p>事件循环(Event Loop)</p>
<p><em>关于Node.js的事件循环, 见我的关于Node.js的文章<a href="https://sien75.github.io/blog/2020/09/08/Node-js%E5%9F%BA%E7%A1%80/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop">Node.js基础</a></em></p>
<p>在Web中, 有大量的多线程操作, 比如I/O(ajax, 读文件等), UI交互, 定时器, 上面提到的Worker等, 为了不阻塞主线程, 它们最好是<strong>异步</strong>运行, 基于<strong>事件</strong>来通知主线程. 同时, 我们还可以通过Promise来对它们包装(Promise代表执行顺序, 是一种异步包装方式, 本身不会开辟新线程执行代码).</p>
<p>浏览器的异步执行方式是这样的:</p>
<p>JavaScript主线程中JavaScript解释器自上而下解释主任务代码, 根据作用域链对执行栈进行压栈弹栈, 遇到多线程代码会开辟子线程处理. 子线程的代码只要执行完毕, 就会触发事件通知主线程, 并往任务队列里面添加任务. 主线程接到事件通知, 待空闲时就会检测任务队列, 只要其中有任务, 就出队一个任务, 将其压入执行栈执行, 执行完毕后再次在任务队列里取任务, 直到任务队列为空. 这就是<code>事件循环(Event Loop)</code>机制.</p>
<p>如下图所示, 任务分为两种, <code>micro task(微任务)</code>和<code>macro task(宏任务)</code>, 前者主要包含包含<code>Promise</code>, 后者包含主任务, <code>setTimeout</code>, <code>setInterval</code>, I/O, UI交互, postMessage等. JavaScript主线程会先从宏任务队列中出队一个任务来执行(第一次取出的就是主任务), 任务执行完毕后再读取微任务队列, 并按顺序执行所有的微任务, 只有微任务队列没有事件时, 才会再次读取宏任务队列. 这样的话, 如果某些前面的任务执行特别耗时间的话, <code>setTimeout</code>和<code>setInterval</code>这些函数的定时可能是不准确的.</p>
<p><img src="./event_loop.png" alt="浏览器中的事件循环"></p>
<p>关于<code>requestAnimationFrame</code>, 它是异步执行(基于事件)的, 但它既不是微任务, 也不是宏任务. 可以认为还存在一个<code>requestAnimationFrame</code>任务队列, 在每次事件循环的渲染步骤前(参考上图), 会检测是否有<code>requestAnimationFrame</code>任务, 并全部执行.</p>
<blockquote>
<p>在现代Chrome浏览器里面, <code>setTimeout</code>和<code>setInterval</code>的时间最小设置值是1(ms), 也就是说第二个参数设为1和0是一样的.</p>
</blockquote>
<blockquote>
<p>由于一方面不好确认浏览器的最佳刷新间隔, 另一方面<code>setTimeout</code>和<code>setInterval</code>受到事件循环中延时的影响更大, 所以自定义动画推荐使用<code>requestAnimationFrame</code>.</p>
</blockquote>
<p>下面是关于浏览器事件循环的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)&#125;, <span class="number">0</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> promise;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">依次显示</span></span><br><span class="line"><span class="comment">Promise</span></span><br><span class="line"><span class="comment">Hi!</span></span><br><span class="line"><span class="comment">resolved</span></span><br><span class="line"><span class="comment">setTimeout0</span></span><br><span class="line"><span class="comment">setTimeout1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p><em>此部分参考了<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a></em></p>
<ol>
<li><p>基本用法.</p>
<p>主线程(JavaScript解释器线程):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span><br><span class="line">worker.postMessage(&#123;<span class="attr">content</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;main thread recieved message!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">worker.onerror = <span class="built_in">console</span>.error;</span><br></pre></td></tr></table></figure>
<p>Worker线程全局环境绑定了监听函数和消息发送函数, work.js的内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;web worker recieved message!&#x27;</span>);</span><br><span class="line">    postMessage(&#123;<span class="attr">content</span>: <span class="string">&#x27;Hello too&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭Worker线程:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">worker.terminate();<span class="comment">//主线程内</span></span><br><span class="line">close();<span class="comment">//Worker线程内</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据通信.</p>
<p>主线程和Worker线程之间的通信是拷贝的关系, 即先把通信内容串行化(转换成字符串), 接收方再将其还原. 主线程和Worker线程之间也可以交换二进制数据, 但是如果二进制数据太大, 这样的拷贝既浪费时间, 又浪费存储资源. 在此, 可以通过直接将二进制数据转移给Worker线程.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line">worker.postMessage(</span><br><span class="line">    &#123;ab1, ab2&#125;,</span><br><span class="line">    [ab1, ab2]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中第一个参数就是指传递的变量, 第二个参数是一个数组, 包含了需要转移的二进制数据变量名.</p>
</li>
<li><p>同文件的Web Worker.   </p>
<p>使用Web Worker可以不用单独的文件, 借助Blob类型的URL构造能力, 可以在单个文件内创建Web Worker.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let work &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F;web worker codes</span><br><span class="line">&#125;</span><br><span class="line">let blob &#x3D; new Blob(&#96;($&#123;work.toString()&#125;)()&#96;);</span><br><span class="line">let url &#x3D; URL.createObjectURL(blob);</span><br><span class="line">let worker &#x3D; new Worker(url);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">let work &#x3D; &#96;</span><br><span class="line">    &#x2F;&#x2F;web worker codes</span><br><span class="line">&#96;;</span><br><span class="line">let blob &#x3D; new Blob(work);</span><br><span class="line">let url &#x3D; URL.createObjectURL(blob);</span><br><span class="line">let worker &#x3D; new Worker(url);   </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>建议参考<a target="_blank" rel="noopener" href="https://lavas-project.github.io/pwa-book/chapter04.html">https://lavas-project.github.io/pwa-book/chapter04.html</a>, 文章把Service Worker作为PWA技术的一部分, 讲解得非常详实. 由于Service Worker并不是一种基础知识, 在此我就不总结了.</p>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
      <a rel="prev" class="post-nav-item mdui-float-left" href="/blog/2020/09/08/Node-js%E5%9F%BA%E7%A1%80/">
        <i class="iconfont icon-angle-left"></i>
        <span>Node.js基础</span>
      </a>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/blog/2020/08/24/HTTP%E5%9F%BA%E7%A1%80/">
        <span>HTTP基础</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>




  <div class="toc-button"  style="z-index: 100;">
    <button class="mdui-fab mdui-ripple mdui-color-teal" mdui-menu="{target: '#toc'}"><i class="iconfont icon-list"></i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item">
        <a href="/blog/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" id="toc-header" class="mdui-ripple">文章目录</a>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">浏览器的工作原理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8-%E2%80%93-Storage"><span class="toc-number">2.</span> <span class="toc-text">客户端存储 – *Storage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8-%E2%80%93-IndexedDB"><span class="toc-number">3.</span> <span class="toc-text">客户端存储 – IndexedDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Worker"><span class="toc-number">5.</span> <span class="toc-text">Web Worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-Worker"><span class="toc-number">6.</span> <span class="toc-text">Service Worker</span></a></li></ol>
      </li>
    </ul>
  </div>



  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
      <span>
        &copy; 2019 - 2020 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        sien75
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>







<script src="/blog/js/mdui.min.js"></script>
<script src="/blog/js/meadow.js"></script>

</body>
</html >