<h1>AI Flow开发工具设计</h1>

<p>最近<code>Vibe Coding(氛围编程)</code>这个概念特别火, 很多人都在使用例如Bolt, Cursor之类的工具进行编程, 这极大提高了编程效率. 在编写小型应用时, 大模型能够发挥强大的局部代码生成能力. 然而当应用规模变大, 应用逻辑变复杂之后, 受限于大模型的能力, 还无法方便地<code>Vibe Coding</code>.</p>
<p>个人认为, 需要一款全新的工具, 创建合适的Vibe(氛围), 使开发者<strong>高效</strong>, <strong>可靠</strong>地使用大模型编写复杂应用.</p>
<h2>AI Flow开发工具的核心设计思路</h2>
<p>首先, 在这里用一段简短的话, 概括AI Flow开发工具的核心设计思路:</p>
<p><strong>以分功能和分种类的思维拆分模块, 在大模型的帮助下进行模块实现和模块组装, 并且借助于流程图的组织性和直观性, <span style="color: red">确保人能较快理清和掌控各个模块和流程</span></strong>.</p>
<p>上面为一段概述, 观点可能并不新颖, 但是关键是是否有一套可行的具体方案.</p>
<h2>现有开发和维护模式的问题分析</h2>
<p>在阐述具体的功能和实现方式之前, 我们先来分析现有的开发和维护模式存在哪些问题.</p>
<h3>使用大模型编码的问题</h3>
<ul>
<li>大模型上下文窗口有限制</li>
<li>大模型无法处理好复杂的业务逻辑</li>
<li>大模型幻觉, 代码是否正确并不好验证</li>
</ul>
<p>只要使用过相关的开发工具, 想必对这些问题都有一定的感触. 这些问题证明了<strong>大模型的能力边界</strong>: 大模型擅长文本编写, 并不擅长复杂的逻辑编排; 大模型擅长做局部的代码新增, 不擅长在复杂的代码里修修改改.</p>
<h3>真的只是受限于大模型吗</h3>
<p>其实我们需要把视角从大模型这边移开, 既然明确了大模型的能力边界, 如果纯文本编码开发的方式和大模型不能更好的兼容, 这是不是可以说明:</p>
<ol>
<li><strong>纯文本编码开发方式并不能完全适配大模型</strong>, 需要一种新的开发方式, 去兼容, 去最大程度释放大模型能力</li>
<li>另一方面, <strong>纯文本编码也不方便开发者去检查和审核</strong>, 除非对代码进行详细审查, 否则对于大模型的错误无能为力</li>
</ol>
<h3>纯文本表达方式的问题</h3>
<p>虽然纯文本表达能力强, 表达成本低, 但是存在以下问题:</p>
<ul>
<li>文本的<strong>组织能力差</strong>, 本质上是一种一维的表达方式, 不方便规范化, 模块和模块之间的关系不直观</li>
<li>文本的<strong>理解成本高</strong>, 想理清一段代码(尤其是命令式的逻辑代码)需要花费很大精力</li>
<li>文本之间通过目录(树状结构)连接, 这<strong>并不能完全体现代码之间的关系</strong>, 因为代码并非文章, 而是有更复杂和严谨的逻辑关系</li>
</ul>
<p>文本是应用开发的表达媒介, 然而应用开发需要将不同模块严谨地组织起来, 也需要降低维护和理解门槛(无论是对其他开发者还是本人日后维护). 即使大模型能够去生成复杂应用的代码, 那对于这一堆文本代码, 开发者需要花费很大的精力去检查代码是否符合预期, 去排查发现的问题.</p>
<h3>应用开发的&quot;三高&quot;</h3>
<p>应用开发中存在很多的心智负担, 主要体现为应用开发的&quot;三高&quot;, 即开发成本高, 调试成本高, 测试成本高. <strong>很多当前的工作原则上并不合理</strong>, 即使这是大家习以为常的.</p>
<h4>开发成本高</h4>
<p>为了方便后续的维护, 开发阶段应该包含&quot;应用描述&quot;(如产品文档)和&quot;应用编码&quot;两部分的产出, 将应用描述翻译为应用编码, 涉及到模块拆分和转译代码, 这是一项很大的开发成本.</p>
<p>理想的开发方式是, 使用大模型<strong>低成本</strong>和<strong>高参与</strong>的进行模块拆分和转译代码.</p>
<h4>调试成本高</h4>
<p>在需要理清代码逻辑或解Bug时, 我们往往需要打断点调试或打日志调试.</p>
<p>如果系统<strong>天然具备便捷的调试能力</strong>, 就不需要提前打断点或打日志这些工作.</p>
<h4>测试成本高</h4>
<p>现在很多系统设计有较强的耦合性, 没有拆分成为可维护的模块, 且不具备针对模块的测试. 另外, 很多时候大家不会太重视测试工作, 这个很大程度上是因为编写测试代码是一项很费劲的工作.</p>
<p>因此理想的测试方式是, <strong>模块测试和代码模块收敛到一起</strong>, 且能一定程度<strong>自动地描述和执行测试流程</strong>.</p>
<h3>应用的运维成本</h3>
<p>在应用上线后, 还有很多的运维工作要做, 比如异常监控, 流量监控, 日志分析等. 在我看来, 这些运维工作, 无论是为了故障发现, 还是产品分析, 本质上是一类工作, 在技术实现上是一码事.</p>
<p>应用的运维, 其实类似于调试和测试步骤, 都是侧重于观察代码的执行结果. 这两种行为的主要区别, 主要表现为一个是线上一个是线下, 线上是真实数据, 侧重用户行为分析, 线下是mock数据, 侧重功能正确无误.</p>
<p><strong>内聚的系统最高效</strong>. 由于大模型会简化很多事情, 并考虑到调试, 测试和运维, 本质上是一码事, 因此将这些功能全部收敛到一个系统内, 可以避免因功能分散到多个系统, 而导致的<strong>对接, 权限管理, 学习成本和重复建设等问题</strong>.</p>
<h3>总结</h3>
<p>当下使用大模型编码遇到的问题, 有很大一部分, 是<strong>掣肘于这套传统的开发模式本身的能力</strong>.</p>
<p>所以接下来, 我要提出一套<strong>基于<code>Flow(流程图)</code>+<code>大模型</code>的开发模式</strong>, 并设计一套<strong>内聚的应用开发系统</strong>, 并解释这套开发模式和开发系统是如何解决当下遇到的问题.</p>
<p>诚然, 这套开发模式本身并不强依赖大模型能力, 也就是说, 没有大模型这套流程照样可以跑通. 然而, 在人工编码的方式下, 这套开发模式在很多方面是鸡肋的, 尤其是涉及到具体编码时它可能不符合很多人的直觉. 恰好, 大模型能够处理很多编码脏活累活, 如果去除了脏活累活, 这套开发模式的<strong>高效和可靠的优势</strong>就会显现出来.</p>
<h2>AI Flow开发工具的功能设计</h2>
<p>下面来详细看一下AI Flow开发工具的主要功能设计, 如果您对理论分析不感兴趣, 可以直接从这里开始看.</p>
<p>再次阐述一遍AI Flow开发工具的核心设计思路:</p>
<p>以分功能和分种类的思维拆分模块, 在大模型的帮助下进行模块实现和模块组装, 并且借助于流程图的组织性和直观性, 确保人能较快理清和掌控各个模块和流程.</p>
<h3>多大模型合作模式(Multi-Agent)</h3>
<p>虽然大模型可以低成本的生成局部代码, 但是对于复杂应用, 单一实例或单一种类的大模型无法做好全部开发工作. 为了提高大模型的代码生成的参与度, 一个更好的架构是, <strong>由多个大模型实例或多种大模型去配合</strong>, 进行需求分析, 模块拆分, 模块实现和模块组装.</p>
<p>类似于公司内的员工管理模型, 多大模型配合也可以使用类似的思路, 将不同层次的任务分工给不同的大模型实例, 如下图:</p>
<p><img src="./corporation-model.drawio.svg" alt="多大模型合作模式"></p>
<h4>架构师</h4>
<p>架构师分为2种, &quot;流程架构师&quot;和&quot;数据架构师&quot;, 负责统筹应用层面的改动.</p>
<p>&quot;流程架构师&quot;Agent对于应用当前的流程架构有统筹的了解, 虽然不了解细节的代码实现, 但是能够<strong>从大面上明确当前的应用执行逻辑</strong>. &quot;流程架构师&quot;Agent会分析产品文档, 然后对应到当前的应用流程架构上, 然后<strong>以自然语言的方式勾勒出应用执行流程的改动</strong>.</p>
<p>&quot;数据架构师&quot;Agent会基于&quot;流程架构师&quot;Agent的输出, 结合自己对于各数据模块的了解, <strong>以自然语言的方式描述出数据结构的变动</strong>, 这包括:</p>
<ol>
<li>对于任务模块, 会描述出该任务模块输入输出数据类型变动</li>
<li>对于数据模块, 会描述出该数据模块数据格式的变动</li>
</ol>
<blockquote>
<p>大模型不一定能将&quot;架构师&quot;的工作做好, 因此架构设计这个工作, 开发者必须深入参与, 确保流程正确合理. 通过流程图的方式可视化表达应用执行流程, 方便开发者检查和修改, 这个下面会提到.</p>
</blockquote>
<blockquote>
<p>&quot;数据架构师&quot;Agent是必须存在的, 因为编码并非简单的连线, 模块之间的输入输出数据格式只有严格对应得上, 才可以保证应用的正常运行.</p>
</blockquote>
<h4>领域专家</h4>
<p>&quot;领域专家&quot;Agent往往负责某一个任务模块. 在领取&quot;架构师&quot;Agent派发的任务后(包含逻辑内容和输入输出数据格式变动), 会根据其当前管理的内容, <strong>以自然语言的方式设计出详细的技术实现方案和测试方案</strong>.</p>
<h4>执行者</h4>
<p>&quot;执行者&quot;Agent会<strong>根据自然语言描述进行实际编码</strong>.</p>
<p>在承接&quot;领域专家&quot;Agent的任务时, &quot;执行者&quot;Agent的上下文是某一个任务文件和这个任务文件涉及到的数据结构.</p>
<p>在承接&quot;数据架构师&quot;Agent的任务时, &quot;执行者&quot;Agent的上下文是这个数据文件.</p>
<h4>测试工程师</h4>
<p>&quot;测试工程师&quot;Agent会<strong>以自然语言编写测试用例, 并实际编码测试</strong>.</p>
<p>在承接&quot;领域专家&quot;Agent的测试任务时, 会根据逻辑内容和输入输出数据格式, 针对任务模块构造Mock数据进行逻辑测试.</p>
<p>在承接&quot;流程架构师&quot;Agent的测试任务时, 会根据逻辑内容和输入输出数据格式, 真实操作数据库和产品, 进行全流程功能测试.</p>
<blockquote>
<p>借助于类似AutoGLM的功能, 包含图形界面的自动化测试也是可以做到的.</p>
</blockquote>
<blockquote>
<p>&quot;测试工程师&quot;Agent并不了解实际的编码, 因此是黑盒测试, 这样能有效防止实际代码的干扰, 更侧重功能层面.</p>
</blockquote>
<h3>模块的分类</h3>
<p>从代码的种类上来看, 模块分为<code>数据模块</code>和<code>任务模块</code>两种, 然后, 再根据实际功能, 可以将一个应用拆分为各个不同的模块. 在本文描述的这套体系内, 代码只应分为数据模块和任务模块, 所以首先在这里澄清一下, 什么是数据模块, 什么是任务模块.</p>
<p>数据模块是一种<strong>声明式模块</strong>, 具备<strong>内部状态</strong>, 且具备<strong>针对内部状态操作的接口</strong>, 可以<strong>序列化</strong>, 且可能对应了某种更加实际的概念. 如: 数据库模块, DOM树, 文件, 内存数据等.</p>
<p>数据模块管理着应用的内部状态和数据通道. 状态的变更, 数据的更新, 都需要数据模块提供接口.</p>
<p>任务模块是一种<strong>命令式模块</strong>, 接收某种类型的数据, 对数据进行处理, 并输出某种类型的数据. 如: 订单处理模块, 任务分发模块等.</p>
<p>理想的任务模块应该是纯函数, 或者至少只依赖<strong>语言引擎提供的能力</strong>的函数(如延时能力), 而不应该依赖环境参数, 保证<strong>同样的输入对应同样的输出</strong>.</p>
<h4>数据模块的组成成分</h4>
<p>定义数据模块需要以下几部分:</p>
<ul>
<li>自然语言部分<ul>
<li>总体描述, 使用自然语言总体描述这种类型数据的用途</li>
<li>接口文档, 以文档的形式(如Markdown)或类型语言(如纯TypeScript声明)的形式, 详细描述这一模块的接口</li>
</ul>
</li>
<li>代码部分, 往往由<code>class</code>定义, 是这种数据类型的具体实现</li>
</ul>
<p>在编写数据模块时, <strong>人只去关心最终的数据定义是否符合需要</strong>, 由大模型去编写代码部分. <strong>数据模块以自然语言部分为基准, 可以对应多重代码</strong>, 例如对于一个Web应用, 即使前后端使用了不同语言, 也可以共享数据类型定义.</p>
<p>由于数据模块为声明式模块, 即使数据定义量庞大, 也并不会复杂, 因此<strong>人工审核大模型生成的数据结果, 是一个成本比较低的事情</strong>.</p>
<p>数据模块是具备状态的模块,一种数据模块定义可能会对应着多个实例.</p>
<p>无论是持久化数据还是动态生成的数据, 数据模块实例也是会在运行时创建.</p>
<h4>任务模块的组成成分</h4>
<p>定义任务模块需要以下几部分:</p>
<ul>
<li>自然语言部分<ul>
<li>总体描述, 描述算法的作用</li>
<li>输入输出描述, 明确任务模块的输入是什么数据结构, 输出是什么数据结构</li>
</ul>
</li>
<li>代码部分, 在形式上为一个<code>function</code>, 是算法的具体实现</li>
<li>测试用例, 构造Mock数据, 并自动执行测试, 是确保算法准确的关键</li>
</ul>
<p>在AI Flow开发工具的整体设计上, 任务模块到底由谁实现, 是这样分工的:</p>
<ol>
<li>对于自然语言部分, 由大模型领取生成任务后自动生成, 也可由人工手动编写</li>
<li>对于代码部分, 由大模型依据自然语言部分的描述自动生成</li>
<li>对于测试用例, 由大模型<strong>依据自然语言部分的描述--而不是依据代码部分</strong>自动生成几组Mock数据和期望值, 即在模块维度上进行黑盒测试, 防止受到代码部分可能存在的错误的影响</li>
</ol>
<p>在这套开发体系中, 开发者<strong>无需关注算法的具体实现, 只需声明期望的功能</strong>, 并可以<strong>通过测试用例去检查算法的准确性和性能表现</strong>, 编写算法的工作完全交给大模型去做.</p>
<h3>拼接模块实际执行+流程图可视化</h3>
<p>为了解决纯文本表达方式的问题, 以及提高大模型的参与度, 并方便开发者检查(进行调试和测试), 一个思路是, 将符合需求的数据定义和准确可靠的任务函数, <strong>通过可视化的流程图串联起来</strong>.</p>
<p>在构建应用时, 我们主要使用函数式编程中<strong>Compose</strong>(组合)的概念, <strong>以任务模块为&quot;树干&quot;, 以对数据模块的操作为&quot;树叶&quot;和&quot;树根&quot;, 组装&quot;应用大树&quot;</strong>. 如下图:</p>
<p><img src="./compose.drawio.svg" alt="拼接模块"></p>
<p>流程图的要点包括:</p>
<ol>
<li>在流程图中, task部分即为任务模块, data部分即为数据模块, 云朵形状为对数据模块的操作, 其中<strong>上方云朵为数据输入, 下方云朵为数据输出</strong></li>
<li>应用的核心流程由任务模块描述, <strong>由左到右依次执行</strong></li>
<li>为了保证主流程清晰在&quot;应用大树&quot;中没有包含数据模块, <strong>只是包含了对数据模块的操作</strong></li>
<li>数据模块之间的依赖关系, 由<strong>专门的数据关系图</strong>描述</li>
</ol>
<blockquote>
<p>流程清晰, 方便测试是函数式编程很大的优势. 只要通过测试的方式保证各任务模块的准确自洽, 那么人只需要重点保证整体上的流程符合期望, 不再需要关注具体的细节, 且模块很容易实现移植和替换(例如tsc的移植: ).</p>
</blockquote>
<p>通过点击模块上的按钮, 可以详细查看模块的内容, 并使用大模型进行修改. 如下图:</p>
<p><img src="./module-detail.drawio.svg" alt="模块组成"></p>
<h3>集合各类运维功能</h3>
<p>为了完善AI Flow开发工具, 需要<strong>集合各类运维功能</strong>, 如下图:</p>
<p><img src="./integration.drawio.svg" alt="集成功能"></p>
<p>将开发模式切换为<strong>运维模式</strong>, 即可使用运维功能, 这包括:</p>
<ol>
<li>配置功能, 方便修改持久化数据, 具备动态修改数据的能力, 无需专门的配置平台</li>
<li>数据可视化功能, 方便以图表的形式对持久化数据进行数据分析</li>
<li>发布功能, 切换运维模式后, 可直接发布到线上</li>
<li>监控功能, 每个任务模块都具备流量记录, 日志记录, 错误捕获和性能测量能力, 且可以直观的显示在流程图上</li>
</ol>
<p>内聚的系统最高效. 将上面这些功能全部集合到系统中, 统一管理, 也均可享受系统的流程设计和大模型能力.</p>
<blockquote>
<p>受到大模型的影响, 一方面更多的任务会由大模型接替, 平台和平台之间的差异性会降低, 另一方面开发+运维团队的人员规模必然会降低, 因此个人认为将运维功能集合是一种大的趋势.</p>
</blockquote>
<h2>如何实现AI Flow开发工具</h2>
<p>下面是实现AI Flow开发工具的具体技术方案.</p>
<p>开发原则: 首先MVP验证, 先做关键部分, 且尽量使用现成的开源工具.</p>
<p>初始支持的开发场景为: Web应用开发(前端+后端).</p>
<h3>代码框架设计</h3>
<h4>基础依赖选型</h4>
<p>初始支持的开发语言: JavaScript (运行环境: 后端 - Bun, 前端 - Chrome).</p>
<p>持久化存储(初始支持):</p>
<p>UI框架(初始支持):</p>
<h4>基础依赖选型</h4>
<p>数据模块; 流程设计</p>
<p>模式验证:</p>
<h3>使用大模型编写代码(MVP)</h3>
<p>类似工具参考: Cline</p>
<h3>构造多大模型合作模式(MVP)</h3>
<h3>操作和渲染流程图</h3>
<p>类似工具参考: 扣子 NodeRed</p>
<p>流程图选型: Mermaid NodeRed</p>
<h3>将流程图和代码关联</h3>
<p>DSL设计: 代码即DSL</p>
<h3>多语言支持</h3>
<p>如有些高性能模块是由不同语言实现的, 可以直接引入使用</p>
<p>多语言混合编译, 例如通过接口文档实现不同语言的数据结构类型</p>
<h2>一些问题</h2>
<p>和现有的Cursor, Bolt的异同?</p>
<p>同样是大模型编写代码, Cursor和Bolt这些工具都无法保证复杂场景下产出代码的准确性. 而AI Flow开发工具借助模块设计, 流程设计和人工介入, 确保了即使在复杂应用中也能高效和准确.</p>
<p>是低代码平台吗?</p>
<p>不是, 并不致力于不写代码编程, 也不会试图抹去编程的复杂性, 当然会有分层次的设计, 可以只关注上层, 不关注底层.</p>
<p>能编写什么类型的应用?</p>
<p>适合编写抽象层级较高, 远离计算机底层, 逻辑密集而非资源密集, 或数据处理等类型的应用.</p>
